{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIT Cyber Range Kyoushi - Simulation \u00b6 The Kyoushi Simulation package provides a development API and cli utilities for creating and running state machines. Developed state machines can be executed to automate the simulation of both attacker and normal user behavior in a Cyber Range. Thus facilitating Cyber Range exercises, IDS data set generation and other Cyber Range related tasks. Check out the Documentation of this package.","title":"Overview"},{"location":"#ait-cyber-range-kyoushi-simulation","text":"The Kyoushi Simulation package provides a development API and cli utilities for creating and running state machines. Developed state machines can be executed to automate the simulation of both attacker and normal user behavior in a Cyber Range. Thus facilitating Cyber Range exercises, IDS data set generation and other Cyber Range related tasks. Check out the Documentation of this package.","title":"AIT Cyber Range Kyoushi - Simulation"},{"location":"contributing/","text":"Contributing \u00b6 Packaging and Installation \u00b6 This project uses poetry for packaging and dependency management. So before you can start developing you will have to install poetry . Please refer to the poetry documentation on how to install and use poetry . After you have installed poetry you can use it to install a local development clone of the repository using: $ poetry install Tests can be run using poetry or by using the Makefile provided with the project. $ poetry run pytest $ make test # or if you wish to generate a HTML coverage report $ make test-html Code Quality and Formatting \u00b6 This project uses pre-commit and various code linters and formatters to ensure that committed code meets certain quality criteria. Note that these criteria are also checked by CI pipelines. This means that should you push unchecked code the pipelines will fail! So it is highly recommend that you install pre-commit so that such code does not make it into the the git history. To make sure that you don't accidentally commit code that does not follow the coding style, you can install a pre-commit hook that will check that everything is in order: $ poetry run pre-commit install The pre-commit git hook runs automatically when you try to commit your changes. It will automatically check and try to format your code. Should your code not conform to the quality criteria or if some re-formatting was necessary the commit will fail. In such cases verify the formatting changes made by pre-commit and fix any other code quality issues reported by the checks before committing your changes again. You can also manually run the pre-commit hook by issuing the following command. $ poetry run pre-commit run --all-files Alternatively you can also use the Makefile to run just the quality checks, auto formatting or just specific checks. $ make check $ make format Run make list for a full list of available make targets. Testing & Code Coverage \u00b6 New code should also always be covered by corresponding tests. Please ensure that all your code is sufficiently covered existing or new tests. Should your MR decrease code coverage significantly or cause any tests to fail it will not be merged. You can check the code coverage of your code in your IDE if it supports reading coverage.xml files or by creating and inspecting a HTML coverage report. $ make test-html The HTML coverage report is created in htmlcov and can be navigated by opening the index.html file. Build & View Documentation \u00b6 This project uses MkDocs for documentation. If you wish to view or edit the docs you can start a live server by running: $ mkdocs serve The live server will automatically detect changes and refresh the documentation. We also provide convenience make targets for building the documentation and starting the live server: # build the distributable documentation site $ make docs # build a offline viewable documentation site, without web server simply open the index file # (Note that the search function is disabled with this) $ make docs-offline # start the mkdocs live server $ make docs-serve","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#packaging-and-installation","text":"This project uses poetry for packaging and dependency management. So before you can start developing you will have to install poetry . Please refer to the poetry documentation on how to install and use poetry . After you have installed poetry you can use it to install a local development clone of the repository using: $ poetry install Tests can be run using poetry or by using the Makefile provided with the project. $ poetry run pytest $ make test # or if you wish to generate a HTML coverage report $ make test-html","title":"Packaging and Installation"},{"location":"contributing/#code-quality-and-formatting","text":"This project uses pre-commit and various code linters and formatters to ensure that committed code meets certain quality criteria. Note that these criteria are also checked by CI pipelines. This means that should you push unchecked code the pipelines will fail! So it is highly recommend that you install pre-commit so that such code does not make it into the the git history. To make sure that you don't accidentally commit code that does not follow the coding style, you can install a pre-commit hook that will check that everything is in order: $ poetry run pre-commit install The pre-commit git hook runs automatically when you try to commit your changes. It will automatically check and try to format your code. Should your code not conform to the quality criteria or if some re-formatting was necessary the commit will fail. In such cases verify the formatting changes made by pre-commit and fix any other code quality issues reported by the checks before committing your changes again. You can also manually run the pre-commit hook by issuing the following command. $ poetry run pre-commit run --all-files Alternatively you can also use the Makefile to run just the quality checks, auto formatting or just specific checks. $ make check $ make format Run make list for a full list of available make targets.","title":"Code Quality and Formatting"},{"location":"contributing/#testing-code-coverage","text":"New code should also always be covered by corresponding tests. Please ensure that all your code is sufficiently covered existing or new tests. Should your MR decrease code coverage significantly or cause any tests to fail it will not be merged. You can check the code coverage of your code in your IDE if it supports reading coverage.xml files or by creating and inspecting a HTML coverage report. $ make test-html The HTML coverage report is created in htmlcov and can be navigated by opening the index.html file.","title":"Testing &amp; Code Coverage"},{"location":"contributing/#build-view-documentation","text":"This project uses MkDocs for documentation. If you wish to view or edit the docs you can start a live server by running: $ mkdocs serve The live server will automatically detect changes and refresh the documentation. We also provide convenience make targets for building the documentation and starting the live server: # build the distributable documentation site $ make docs # build a offline viewable documentation site, without web server simply open the index file # (Note that the search function is disabled with this) $ make docs-offline # start the mkdocs live server $ make docs-serve","title":"Build &amp; View Documentation"},{"location":"license/","text":"MIT License Copyright (c) 2020 AIT Austrian Institute of Technology Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"examples/decorated_traveler/","text":"Traveler Example \u00b6 Hint See the examples directory for the full code example. This example is an alternative implementation of the state machine shown in the traveler example . The implementation does not use stateful transitions and uses transition decorators as an alternative to creating transition instances in the factory build method. Here we will only show case the implementation changes for the full example description please take a look at traveler example . Traveler state machine Context \u00b6 Since we do not use stateful transition functions in this version, we need to provide the configuration options to the modified transition functions as part of the context. For our simple example it is enough to base our TravelerContext on our TravelerConfig instead BaseModel . This way TravelerContext will inherit all attributes from TravelerConfig . class TravelerContext ( TravelerConfig ): current_location : Optional [ StrictStr ] = Field ( None , description = \"The current location of the traveler.\" ) chosen_city : Optional [ StrictStr ] = Field ( description = \"The city the traveler as chosen as potential travel destination.\" ) weather : Optional [ Weather ] = Field ( description = \"The weather in the chosen city according to the travelers research.\" ) For the traveler state machine we use the context to share the current location , city and the weather in the city across multiple transitions. Decorated Transition Functions \u00b6 Reminder We have the following transitions: hello : For this transition we will print the name of our traveler and what kind of weather they like. select_city : Here our traveler will randomly choose a potential travel destination from the list of cities. check_weather : After choosing a destination they will have to check the weather in the city. going_to_city : Should the weather be to our travelers liking they will tell us so and that they are going to the city. not_going : Should it not be to their liking then the traveler will inform us that they changed their mind. arrive : Once the traveler has arrived the city they again will inform us. going_to_sleep : Finally should the traveler have grown tiered of traveling for the day they will let us know and then go to sleep. Using transition decorators like [ transitions.transition ][cr_kyoushi.simulation.transitions.transition] we can directly turn a transition function into a transition. This is helpful to keep our code short and concise as we will not have to manually create a transition instance in our factories build method. Note Using a transition decorator on a transition function is equivalent to initializing a transition by passing the transition function i.e., @transitions . transition ( target = \"some_state\" ) def do_something ( log , current_state , context , target ): print ( \"something\" ) is equivalent to def do_something_function ( log , current_state , context , target ): print ( \"something\" ) do_something = transitions . Transition ( do_something_function , name = \"do_something\" , target = \"some_state\" ) Updated transition functions \u00b6 The hello transition now reads the traveler and and preferred weather from the config instead of having its own state. @transitions . transition ( target = \"selecting_city\" ) def hello ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): \"\"\"Transition function for the initial hello world message\"\"\" print ( f \"Hi I am { context . traveler } . \" f \"I like to travel to cities that have { context . desired_weather } weather.\" ) To select a city we need to first inline convert the weather map to a list of cities. @transitions . delayed_transition ( target = \"researching\" , delay_after = 3 ) def select_city ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): cities = list ( context . cities . keys ()) context . chosen_city = StrictStr ( random . choice ( cities )) print ( f \"Maybe I will travel to somewhere in { context . chosen_city } .\" ) Note For the sake of execution efficiency one could also define the context and function so that this conversion is only executed on the first call and then persisted as part of the context. For the weather check we now simply access the map through the context. @transitions . delayed_transition ( target = \"deciding\" , delay_before = 1 , delay_after = 1 ) def check_weather ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): \"\"\"Transition function to check the weather in the chosen city\"\"\" context . weather = context . cities [ StrictStr ( context . chosen_city )] print ( f \"The weather is { context . weather } in { context . chosen_city } \" ) Other than the decorator and name this is unchanged. @transitions . delayed_transition ( target = \"traveling\" , delay_after = 10 ) def going_to_city ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"The weather is ok so I am going to { context . chosen_city } now ...\" ) Other than the decorator and name this is unchanged. @transitions . delayed_transition ( target = \"selecting_city\" , delay_before = 2 ) def not_going ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"I don't like the weather in { context . chosen_city } so I am not going ...\" ) context . chosen_city = None context . weather = None Other than the decorator and name this is unchanged. @transitions . transition ( target = \"in_city\" ) def arrive ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"I have arrived in { context . chosen_city } the weather is { context . weather } just how I like it.\" ) context . current_location = context . chosen_city context . chosen_city = None context . weather = None Similarly to the updated hello transition we now access the traveler name through the context. @transitions . delayed_transition ( target = \"sleeping\" , delay_before = 3.5 ) def going_to_sleep ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): \"\"\"Transition function that prints the final message before the traveler goes to sleep\"\"\" print ( f \"I { context . traveler } have travelled enough for now.\" ) print ( f \"I am going to sleep in { context . current_location } ...\" ) print ( \"... zzzZZZzz ...\" ) Statemachine and Context Setup \u00b6 Since our modified TravelerContext now also contains the configuration options we have to modify our state machine initialization and [context setup][cr_kyoushi.simulation.sm.Statemachine.setup_context]. Previously we simply created a TravelerContext instance with everything set to its default values. In this version we pass our TravelerConfig instance when constructing the context. class TravelerStatemachine ( sm . Statemachine ): def __init__ ( self , initial_state : str , states : List [ states . State ], config : TravelerConfig , max_errors : int = 0 , ): super () . __init__ ( initial_state , states , max_errors = max_errors ) self . __config = config def setup_context ( self ): \"\"\"Initialize with config values and use defaults for the rest\"\"\" self . context = TravelerContext . parse_obj ( self . __config ) Note TravelerContext . parse_obj ( self . __config ) is basically just a short hand provided by Pydantic for: TravelerContext ( traveler = self . __config . traveler , desired_weather = self . __config . desired_weather ) Transition and State Configuration \u00b6 The updated build method shows the biggest advantage of using transition decorator. Since all our transition functions are decorated they are all automatically converted to transitions. This means that we do not have to manually instantiate transition objects, but instead can directly pass the converted transition functions into our states. This approach can significantly simplify and short our build functions and state machine definitions. ... def build ( self , config : TravelerConfig ): # States # ---------------------------------- initial = states . SequentialState ( \"initial\" , hello ) selecting_city = states . SequentialState ( \"selecting_city\" , select_city ) researching = states . SequentialState ( \"researching\" , check_weather ) deciding = DecidingState ( \"deciding\" , going = going_to_city , not_going = not_going , desired_weather = config . desired_weather , ) traveling = states . SequentialState ( \"traveling\" , arrive ) in_city = states . ProbabilisticState ( \"in_city\" , [ going_to_sleep , select_city ], [ 0.3 , 0.7 ] ) sleeping = states . FinalState ( \"sleeping\" ) # Initialize the state machine return TravelerStatemachine ( \"initial\" , [ initial , selecting_city , researching , deciding , traveling , in_city , sleeping , ], config = config , ) Note You can only use transition decorators on functions (i.e., stateless transition functions). This is because stateful transition functions are classes that need to be instantiated before the can be used as transition functions. Running the Example \u00b6 To run the example state machine you can simply use the Cyber Range Kyoushi CLI. $ cd examples/decorated_traveler $ cr-kyoushi-sim -c config.yml run -f traveler.py","title":"Decorated Traveler"},{"location":"examples/decorated_traveler/#traveler-example","text":"Hint See the examples directory for the full code example. This example is an alternative implementation of the state machine shown in the traveler example . The implementation does not use stateful transitions and uses transition decorators as an alternative to creating transition instances in the factory build method. Here we will only show case the implementation changes for the full example description please take a look at traveler example . Traveler state machine","title":"Traveler Example"},{"location":"examples/decorated_traveler/#context","text":"Since we do not use stateful transition functions in this version, we need to provide the configuration options to the modified transition functions as part of the context. For our simple example it is enough to base our TravelerContext on our TravelerConfig instead BaseModel . This way TravelerContext will inherit all attributes from TravelerConfig . class TravelerContext ( TravelerConfig ): current_location : Optional [ StrictStr ] = Field ( None , description = \"The current location of the traveler.\" ) chosen_city : Optional [ StrictStr ] = Field ( description = \"The city the traveler as chosen as potential travel destination.\" ) weather : Optional [ Weather ] = Field ( description = \"The weather in the chosen city according to the travelers research.\" ) For the traveler state machine we use the context to share the current location , city and the weather in the city across multiple transitions.","title":"Context"},{"location":"examples/decorated_traveler/#decorated-transition-functions","text":"Reminder We have the following transitions: hello : For this transition we will print the name of our traveler and what kind of weather they like. select_city : Here our traveler will randomly choose a potential travel destination from the list of cities. check_weather : After choosing a destination they will have to check the weather in the city. going_to_city : Should the weather be to our travelers liking they will tell us so and that they are going to the city. not_going : Should it not be to their liking then the traveler will inform us that they changed their mind. arrive : Once the traveler has arrived the city they again will inform us. going_to_sleep : Finally should the traveler have grown tiered of traveling for the day they will let us know and then go to sleep. Using transition decorators like [ transitions.transition ][cr_kyoushi.simulation.transitions.transition] we can directly turn a transition function into a transition. This is helpful to keep our code short and concise as we will not have to manually create a transition instance in our factories build method. Note Using a transition decorator on a transition function is equivalent to initializing a transition by passing the transition function i.e., @transitions . transition ( target = \"some_state\" ) def do_something ( log , current_state , context , target ): print ( \"something\" ) is equivalent to def do_something_function ( log , current_state , context , target ): print ( \"something\" ) do_something = transitions . Transition ( do_something_function , name = \"do_something\" , target = \"some_state\" )","title":"Decorated Transition Functions"},{"location":"examples/decorated_traveler/#updated-transition-functions","text":"The hello transition now reads the traveler and and preferred weather from the config instead of having its own state. @transitions . transition ( target = \"selecting_city\" ) def hello ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): \"\"\"Transition function for the initial hello world message\"\"\" print ( f \"Hi I am { context . traveler } . \" f \"I like to travel to cities that have { context . desired_weather } weather.\" ) To select a city we need to first inline convert the weather map to a list of cities. @transitions . delayed_transition ( target = \"researching\" , delay_after = 3 ) def select_city ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): cities = list ( context . cities . keys ()) context . chosen_city = StrictStr ( random . choice ( cities )) print ( f \"Maybe I will travel to somewhere in { context . chosen_city } .\" ) Note For the sake of execution efficiency one could also define the context and function so that this conversion is only executed on the first call and then persisted as part of the context. For the weather check we now simply access the map through the context. @transitions . delayed_transition ( target = \"deciding\" , delay_before = 1 , delay_after = 1 ) def check_weather ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): \"\"\"Transition function to check the weather in the chosen city\"\"\" context . weather = context . cities [ StrictStr ( context . chosen_city )] print ( f \"The weather is { context . weather } in { context . chosen_city } \" ) Other than the decorator and name this is unchanged. @transitions . delayed_transition ( target = \"traveling\" , delay_after = 10 ) def going_to_city ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"The weather is ok so I am going to { context . chosen_city } now ...\" ) Other than the decorator and name this is unchanged. @transitions . delayed_transition ( target = \"selecting_city\" , delay_before = 2 ) def not_going ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"I don't like the weather in { context . chosen_city } so I am not going ...\" ) context . chosen_city = None context . weather = None Other than the decorator and name this is unchanged. @transitions . transition ( target = \"in_city\" ) def arrive ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"I have arrived in { context . chosen_city } the weather is { context . weather } just how I like it.\" ) context . current_location = context . chosen_city context . chosen_city = None context . weather = None Similarly to the updated hello transition we now access the traveler name through the context. @transitions . delayed_transition ( target = \"sleeping\" , delay_before = 3.5 ) def going_to_sleep ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): \"\"\"Transition function that prints the final message before the traveler goes to sleep\"\"\" print ( f \"I { context . traveler } have travelled enough for now.\" ) print ( f \"I am going to sleep in { context . current_location } ...\" ) print ( \"... zzzZZZzz ...\" )","title":"Updated transition functions"},{"location":"examples/decorated_traveler/#statemachine-and-context-setup","text":"Since our modified TravelerContext now also contains the configuration options we have to modify our state machine initialization and [context setup][cr_kyoushi.simulation.sm.Statemachine.setup_context]. Previously we simply created a TravelerContext instance with everything set to its default values. In this version we pass our TravelerConfig instance when constructing the context. class TravelerStatemachine ( sm . Statemachine ): def __init__ ( self , initial_state : str , states : List [ states . State ], config : TravelerConfig , max_errors : int = 0 , ): super () . __init__ ( initial_state , states , max_errors = max_errors ) self . __config = config def setup_context ( self ): \"\"\"Initialize with config values and use defaults for the rest\"\"\" self . context = TravelerContext . parse_obj ( self . __config ) Note TravelerContext . parse_obj ( self . __config ) is basically just a short hand provided by Pydantic for: TravelerContext ( traveler = self . __config . traveler , desired_weather = self . __config . desired_weather )","title":"Statemachine and Context Setup"},{"location":"examples/decorated_traveler/#transition-and-state-configuration","text":"The updated build method shows the biggest advantage of using transition decorator. Since all our transition functions are decorated they are all automatically converted to transitions. This means that we do not have to manually instantiate transition objects, but instead can directly pass the converted transition functions into our states. This approach can significantly simplify and short our build functions and state machine definitions. ... def build ( self , config : TravelerConfig ): # States # ---------------------------------- initial = states . SequentialState ( \"initial\" , hello ) selecting_city = states . SequentialState ( \"selecting_city\" , select_city ) researching = states . SequentialState ( \"researching\" , check_weather ) deciding = DecidingState ( \"deciding\" , going = going_to_city , not_going = not_going , desired_weather = config . desired_weather , ) traveling = states . SequentialState ( \"traveling\" , arrive ) in_city = states . ProbabilisticState ( \"in_city\" , [ going_to_sleep , select_city ], [ 0.3 , 0.7 ] ) sleeping = states . FinalState ( \"sleeping\" ) # Initialize the state machine return TravelerStatemachine ( \"initial\" , [ initial , selecting_city , researching , deciding , traveling , in_city , sleeping , ], config = config , ) Note You can only use transition decorators on functions (i.e., stateless transition functions). This is because stateful transition functions are classes that need to be instantiated before the can be used as transition functions.","title":"Transition and State Configuration"},{"location":"examples/decorated_traveler/#running-the-example","text":"To run the example state machine you can simply use the Cyber Range Kyoushi CLI. $ cd examples/decorated_traveler $ cr-kyoushi-sim -c config.yml run -f traveler.py","title":"Running the Example"},{"location":"examples/traveler/","text":"Traveler Example \u00b6 Hint See the examples directory for the full code example. This example implements the following basic state machine that simulates a choosy traveler. The traveler in this example likes to travel to various cities, but only if the current weather there is the weather they like. Also sometimes the traveler gets tired and will go to sleep in the city they are currently in. Traveler state machine Configuration \u00b6 For the traveler 3 things need to be configured: The travelers name so they can say hello The type of weather they like The weather map This is achieved by defining a Pydantic Model containing all the fields and type definitions for the configuration. class TravelerConfig ( BaseModel ): traveler : StrictStr = Field ( StrictStr ( \"Bob\" ), description = \"The travelers name\" ) cities : Dict [ StrictStr , Weather ] = Field ( description = \"A dictionary of cities mapped to their current weather\" ) desired_weather : Weather = Field ( description = \"The weather the traveler likes\" ) Weather Enum In the traveler example the weather is defined in the form of an Enum . The enum uses a custom pydantic validate method to allow case insensitive configuration input. For example any of the following would be valid Weather : heavy rain HEAVY RAIN heAVY raIN class Weather ( str , Enum ) SNOW = \"SNOW\" SLEET = \"SLEET\" HAIL = \"HAIL\" THUNDERSTORM = \"THUNDERSTORM\" HEAVY_RAIN = \"HEAVY RAIN\" LIGHT_RAIN = \"LIGHT RAIN\" SHOWERS = \"SHOWERS\" HEAVY_CLOUD = \"HEAVY CLOUD\" LIGHT_CLOUD = \"LIGHT CLOUD\" CLEAR = \"CLEAR\" @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , val : str ) -> \"Weather\" : \"\"\"Custom case insensitive value enum validator\"\"\" if isinstance ( val , Weather ): return val if isinstance ( val , str ): try : enum_v = Weather ( val . upper ()) except ValueError : raise EnumMemberError ( enum_values = list ( Weather )) return enum_v raise EnumMemberError ( enum_values = list ( Weather )) Using custom validators we can also define additional validation e.g., to ensure that there is at least one city configured and there is at least one city with weather the traveler likes. @validator ( \"cities\" ) def validate_cities ( cls , v : Dict [ StrictStr , Weather ]) -> Dict [ StrictStr , Weather ]: \"\"\"Custom validation method for checking that at least **one** city was configured\"\"\" assert len ( v ) > 0 , \"too few cities, must at least have 1 city\" return v @validator ( \"desired_weather\" ) def validate_desired_weather_exists ( cls , v , values , ** kwargs ): \"\"\"Custom validation method for checking that at lease one city has the weather the traveler likes\"\"\" # if cities is not in values then it failed to validate # so we do nothing if \"cities\" in values and v not in values [ \"cities\" ] . values (): raise TypeError ( f \"Impossible no city with the desired weather { v } \" ) return v Context \u00b6 Similarly to the configuration we also define a Pydantic Model for out state machine context. Here we store context information that is used in multiple transitions. In theory we could use the context to store all information, but for the purposes of this example we will also show case how to create stateful transition functions that do not rely on the state machine context. Such stateful transition functions can be useful if you have want your transition functions to behave differently depending on the passed configuration options. They can also be a useful to prevent the context from growing to large due large amount of fields which are only used by a single transition function. class TravelerContext ( BaseModel ): current_location : Optional [ StrictStr ] = Field ( None , description = \"The current location of the traveler.\" ) chosen_city : Optional [ StrictStr ] = Field ( description = \"The city the traveler as chosen as potential travel destination.\" ) weather : Optional [ Weather ] = Field ( description = \"The weather in the chosen city according to the travelers research.\" ) For the traveler state machine we use the context to share the current location , city and the weather in the city across multiple transitions. Transition Functions \u00b6 Now that we have prepared our state machine config and context models we have to prepare our transition functions. If you refer to the state machine diagram above you can see that we need 7 functions in total. We need functions for the following transitions: hello : For this transition we will print the name of our traveler and what kind of weather they like. select_city : Here our traveler will randomly choose a potential travel destination from the list of cities. check_weather : After choosing a destination they will have to check the weather in the city. going_to_city : Should the weather be to our travelers liking they will tell us so and that they are going to the city. not_going : Should it not be to their liking then the traveler will inform us that they changed their mind. arrive : Once the traveler has arrived the city they again will inform us. going_to_sleep : Finally should the traveler have grown tiered of traveling for the day they will let us know and then go to sleep. Note The transition functions below do not adhere to the order of the list above. Instead they are grouped based on function type to show case the difference between stateless and stateful transition functions Stateless Transition Functions \u00b6 Stateless transition functions are simply functions that follow the function signature provided by the [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] protocol. For the sake of the example we will keep the actual implementation of our transitions simple. Our traveler will mostly just print their current actions to the terminal. 4. To print the city we are going to we simply the to read the passed TravelerContext . def goto_city_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"The weather is ok so I am going to { context . chosen_city } now ...\" ) 5. When the traveler decides to not go to the choses city we also have to reset the city and weather context attributes. def do_not_go_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"I don't like the weather in { context . chosen_city } so I am not going ...\" ) context . chosen_city = None context . weather = None 6. Similarly when we arrive in a city we have to set it in the context and reset our selection information. def arrive_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ] ): print ( f \"I have arrived in { context . chosen_city } the weather\" + f \" is { context . weather } just how I like it.\" ) context . current_location = context . chosen_city context . chosen_city = None context . weather = None Stateful Transition Functions \u00b6 Stateful transition functions implement the [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] protocol through callable objects instead of using simple functions. To define such a callable objects one has only define a __call__(self[, args...]) method. Note Since stateful transition functions are classes you have to create an object instance to use one. 1. For our hello transition function we create a stateful transition function so that we can initialize it with the travelers name and desired weather. class SayHello : def __init__ ( self , traveler_name : StrictStr , desired_weather : Weather ): self . traveler_name = traveler_name self . desired_weather = desired_weather def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"Hi I am { self . traveler_name } . \" + f \"I like to travel to cities that have { self . desired_weather } weather.\" ) 2. To select a random city we have to initialize our function with a list of cities obtained from the weather map. class SelectRandomCity : \"\"\"Transition function that randomly selects a city from the configured list\"\"\" def __init__ ( self , cities : List [ str ]): self . cities = cities def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): context . chosen_city = StrictStr ( random . choice ( self . cities )) print ( f \"Maybe I will travel to somewhere in { context . chosen_city } .\" ) 3. To check the weather we need access to the whole weather map. class CheckWeatherMap : def __init__ ( self , weather_map : Dict [ StrictStr , Weather ]): self . weather_map = weather_map def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): context . weather = self . weather_map [ StrictStr ( context . chosen_city )] print ( f \"The weather is { context . weather } in { context . chosen_city } \" ) 7. Similarly to the hello function for the message we need the travelers name in addition to the their current location. class SleepInCity : def __init__ ( self , traveler_name : StrictStr ): self . traveler_name = traveler_name def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"I { self . traveler_name } have travelled enough for now.\" ) print ( f \"I am going to sleep in { context . current_location } ...\" ) print ( \"... zzzZZZzz ...\" ) Custom State and Context Setup \u00b6 As shown in the state machine diagram above we have a state which selects the successor transition based on the weather the user likes and the chosen cities weather. Such a conditional can be implemented by extending the base state and implementing a custom [ State.next(...) ][cr_kyoushi.simulation.states.State.next] method. The below custom state is initialized with the two possible transitions and the desired weather. The next(...) function then simply checks if the desired weather matches the currently chosen cities weather. class DecidingState ( states . State ): def __init__ ( self , name : str , going : transitions . Transition , not_going : transitions . Transition , desired_weather : Weather , ): super () . __init__ ( name , [ going , not_going ]) self . going = going self . not_going = not_going self . desired_weather = desired_weather def next ( self , log : BoundLogger , context : TravelerContext ) -> Optional [ transitions . Transition ]: if context . weather == self . desired_weather : return self . going return self . not_going In addition to our custom state class we also need to extend the base state machine class so we can extend the default state machine [context setup][cr_kyoushi.simulation.sm.Statemachine.setup_context] method. For our example state machine it is enough to simply initialize the traveler context with its default values. class TravelerStatemachine ( sm . Statemachine ): def setup_context ( self ): \"\"\"Initialize traveler context with default values\"\"\" self . context = TravelerContext () Transition and State Configuration \u00b6 The final step is to define the state machine factory and implement the [build][cr_kyoushi.simulation.sm.StatemachineFactory.build] method. To define the factory we need to set the factory [name][cr_kyoushi.simulation.sm.StatemachineFactory.name] and the [config class][cr_kyoushi.simulation.sm.StatemachineFactory.config_class]. Important The config class must be set to our config type TravelerConfig Important Also note that for python file state machine factory plugins the factory class must be named StatemachineFactory for the plugin system to detect it correctly! class StatemachineFactory ( sm . StatemachineFactory ): @property def name ( self ) -> str : return \"TravelerStatemachineFactory\" @property def config_class ( self ): return TravelerConfig ... Note If you wish you can also define multiple helper functions for your various build steps. For the purposes of this example we decided to put everything in the main build method. The first thing we will have to do is initialize all our stateful transition functions using the traveler config object that is passed to the build method. def build ( self , config : TravelerConfig ): # Stateful transition functions init # ---------------------------------- say_hello = SayHello ( traveler_name = config . traveler , desired_weather = config . desired_weather , ) select_random_city = SelectRandomCity ( cities = list ( config . cities . keys ())) check_weather_on_map = CheckWeatherMap ( weather_map = config . cities ) sleep_in_city = SleepInCity ( traveler_name = config . traveler ) ... Next create our transition objects by initializing them with their unique names , transition functions and their target state names . We decided to use the [ DelayedTransition ][cr_kyoushi.simulation.transitions.DelayedTransition] for some of our transitions. This special transition type allows us to set pre- and/or post transition execution delays. For our example this will simulate our travelers thought process and the time it takes them to execute some of their actions. Tip As you can see in the code below we use hardcoded strings for the transition and state names. For bigger state machines this can lead to mistakes quickly so we suggest to use centrally defined string constants or enums instead. ... hello = transitions . Transition ( name = \"hello\" , transition_function = say_hello , target = \"selecting_city\" , ) select_city = transitions . DelayedTransition ( name = \"select_city\" , transition_function = select_random_city , target = \"researching\" , delay_after = 3 , ) check_weather = transitions . DelayedTransition ( name = \"check_weather\" , transition_function = check_weather_on_map , target = \"deciding\" , delay_before = 1 , delay_after = 1 , ) going_to_city = transitions . DelayedTransition ( name = \"going_to_city\" , transition_function = goto_city_transition , target = \"traveling\" , delay_after = 10 , ) not_going = transitions . DelayedTransition ( name = \"not_going\" , transition_function = do_not_go_transition , target = \"selecting_city\" , delay_before = 2 , ) arrive_in_city = transitions . Transition ( name = \"arrive\" , transition_function = arrive_transition , target = \"in_city\" , ) going_to_sleep = transitions . DelayedTransition ( name = \"going_to_sleep\" , transition_function = sleep_in_city , target = \"sleeping\" , delay_before = 3.5 , ) ... As final step we have to create our states and initialize the state machine with them. Our traveler state machine uses four different types of states. [ SequentialState ][cr_kyoushi.simulation.states.SequentialState]: This is a simple state that only has one outgoing transition making it easy to define a fixed sequence of states. [ ProbabilisticState ][cr_kyoushi.simulation.states.ProbabilisticState]: This state type allows us to assign a probability to each outgoing transition, it is very useful for defining probabilistic state machines and simulating seemingly random behavior. [ FinalState ][cr_kyoushi.simulation.states.FinalState]: As the name states this is a final state with no outgoing transitions, entering this state will stop the state machine. and our custom DecidingState we defined above. We use a [ ProbabilisticState ][cr_kyoushi.simulation.states.ProbabilisticState] to simulate our traveler getting tired. Each time they reach a new city there is 30% chance of them going to sleep instead of continuing their travels. ... initial = states . SequentialState ( \"initial\" , hello ) selecting_city = states . SequentialState ( \"selecting_city\" , select_city ) researching = states . SequentialState ( \"researching\" , check_weather ) deciding = DecidingState ( \"deciding\" , going = going_to_city , not_going = not_going , desired_weather = config . desired_weather , ) traveling = states . SequentialState ( \"traveling\" , arrive_in_city ) in_city = states . ProbabilisticState ( \"in_city\" , [ going_to_sleep , select_city ], [ 0.3 , 0.7 ] ) sleeping = states . FinalState ( \"sleeping\" ) # Initialize the state machine return TravelerStatemachine ( \"initial\" , [ initial , selecting_city , researching , deciding , traveling , in_city , sleeping , ], ) Running the Example \u00b6 To run the example state machine you can simply use the Cyber Range Kyoushi CLI. $ cd examples/traveler $ cr-kyoushi-sim -c config.yml run -f traveler.py","title":"Traveler"},{"location":"examples/traveler/#traveler-example","text":"Hint See the examples directory for the full code example. This example implements the following basic state machine that simulates a choosy traveler. The traveler in this example likes to travel to various cities, but only if the current weather there is the weather they like. Also sometimes the traveler gets tired and will go to sleep in the city they are currently in. Traveler state machine","title":"Traveler Example"},{"location":"examples/traveler/#configuration","text":"For the traveler 3 things need to be configured: The travelers name so they can say hello The type of weather they like The weather map This is achieved by defining a Pydantic Model containing all the fields and type definitions for the configuration. class TravelerConfig ( BaseModel ): traveler : StrictStr = Field ( StrictStr ( \"Bob\" ), description = \"The travelers name\" ) cities : Dict [ StrictStr , Weather ] = Field ( description = \"A dictionary of cities mapped to their current weather\" ) desired_weather : Weather = Field ( description = \"The weather the traveler likes\" ) Weather Enum In the traveler example the weather is defined in the form of an Enum . The enum uses a custom pydantic validate method to allow case insensitive configuration input. For example any of the following would be valid Weather : heavy rain HEAVY RAIN heAVY raIN class Weather ( str , Enum ) SNOW = \"SNOW\" SLEET = \"SLEET\" HAIL = \"HAIL\" THUNDERSTORM = \"THUNDERSTORM\" HEAVY_RAIN = \"HEAVY RAIN\" LIGHT_RAIN = \"LIGHT RAIN\" SHOWERS = \"SHOWERS\" HEAVY_CLOUD = \"HEAVY CLOUD\" LIGHT_CLOUD = \"LIGHT CLOUD\" CLEAR = \"CLEAR\" @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , val : str ) -> \"Weather\" : \"\"\"Custom case insensitive value enum validator\"\"\" if isinstance ( val , Weather ): return val if isinstance ( val , str ): try : enum_v = Weather ( val . upper ()) except ValueError : raise EnumMemberError ( enum_values = list ( Weather )) return enum_v raise EnumMemberError ( enum_values = list ( Weather )) Using custom validators we can also define additional validation e.g., to ensure that there is at least one city configured and there is at least one city with weather the traveler likes. @validator ( \"cities\" ) def validate_cities ( cls , v : Dict [ StrictStr , Weather ]) -> Dict [ StrictStr , Weather ]: \"\"\"Custom validation method for checking that at least **one** city was configured\"\"\" assert len ( v ) > 0 , \"too few cities, must at least have 1 city\" return v @validator ( \"desired_weather\" ) def validate_desired_weather_exists ( cls , v , values , ** kwargs ): \"\"\"Custom validation method for checking that at lease one city has the weather the traveler likes\"\"\" # if cities is not in values then it failed to validate # so we do nothing if \"cities\" in values and v not in values [ \"cities\" ] . values (): raise TypeError ( f \"Impossible no city with the desired weather { v } \" ) return v","title":"Configuration"},{"location":"examples/traveler/#context","text":"Similarly to the configuration we also define a Pydantic Model for out state machine context. Here we store context information that is used in multiple transitions. In theory we could use the context to store all information, but for the purposes of this example we will also show case how to create stateful transition functions that do not rely on the state machine context. Such stateful transition functions can be useful if you have want your transition functions to behave differently depending on the passed configuration options. They can also be a useful to prevent the context from growing to large due large amount of fields which are only used by a single transition function. class TravelerContext ( BaseModel ): current_location : Optional [ StrictStr ] = Field ( None , description = \"The current location of the traveler.\" ) chosen_city : Optional [ StrictStr ] = Field ( description = \"The city the traveler as chosen as potential travel destination.\" ) weather : Optional [ Weather ] = Field ( description = \"The weather in the chosen city according to the travelers research.\" ) For the traveler state machine we use the context to share the current location , city and the weather in the city across multiple transitions.","title":"Context"},{"location":"examples/traveler/#transition-functions","text":"Now that we have prepared our state machine config and context models we have to prepare our transition functions. If you refer to the state machine diagram above you can see that we need 7 functions in total. We need functions for the following transitions: hello : For this transition we will print the name of our traveler and what kind of weather they like. select_city : Here our traveler will randomly choose a potential travel destination from the list of cities. check_weather : After choosing a destination they will have to check the weather in the city. going_to_city : Should the weather be to our travelers liking they will tell us so and that they are going to the city. not_going : Should it not be to their liking then the traveler will inform us that they changed their mind. arrive : Once the traveler has arrived the city they again will inform us. going_to_sleep : Finally should the traveler have grown tiered of traveling for the day they will let us know and then go to sleep. Note The transition functions below do not adhere to the order of the list above. Instead they are grouped based on function type to show case the difference between stateless and stateful transition functions","title":"Transition Functions"},{"location":"examples/traveler/#stateless-transition-functions","text":"Stateless transition functions are simply functions that follow the function signature provided by the [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] protocol. For the sake of the example we will keep the actual implementation of our transitions simple. Our traveler will mostly just print their current actions to the terminal. 4. To print the city we are going to we simply the to read the passed TravelerContext . def goto_city_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"The weather is ok so I am going to { context . chosen_city } now ...\" ) 5. When the traveler decides to not go to the choses city we also have to reset the city and weather context attributes. def do_not_go_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"I don't like the weather in { context . chosen_city } so I am not going ...\" ) context . chosen_city = None context . weather = None 6. Similarly when we arrive in a city we have to set it in the context and reset our selection information. def arrive_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ] ): print ( f \"I have arrived in { context . chosen_city } the weather\" + f \" is { context . weather } just how I like it.\" ) context . current_location = context . chosen_city context . chosen_city = None context . weather = None","title":"Stateless Transition Functions"},{"location":"examples/traveler/#stateful-transition-functions","text":"Stateful transition functions implement the [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] protocol through callable objects instead of using simple functions. To define such a callable objects one has only define a __call__(self[, args...]) method. Note Since stateful transition functions are classes you have to create an object instance to use one. 1. For our hello transition function we create a stateful transition function so that we can initialize it with the travelers name and desired weather. class SayHello : def __init__ ( self , traveler_name : StrictStr , desired_weather : Weather ): self . traveler_name = traveler_name self . desired_weather = desired_weather def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"Hi I am { self . traveler_name } . \" + f \"I like to travel to cities that have { self . desired_weather } weather.\" ) 2. To select a random city we have to initialize our function with a list of cities obtained from the weather map. class SelectRandomCity : \"\"\"Transition function that randomly selects a city from the configured list\"\"\" def __init__ ( self , cities : List [ str ]): self . cities = cities def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): context . chosen_city = StrictStr ( random . choice ( self . cities )) print ( f \"Maybe I will travel to somewhere in { context . chosen_city } .\" ) 3. To check the weather we need access to the whole weather map. class CheckWeatherMap : def __init__ ( self , weather_map : Dict [ StrictStr , Weather ]): self . weather_map = weather_map def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): context . weather = self . weather_map [ StrictStr ( context . chosen_city )] print ( f \"The weather is { context . weather } in { context . chosen_city } \" ) 7. Similarly to the hello function for the message we need the travelers name in addition to the their current location. class SleepInCity : def __init__ ( self , traveler_name : StrictStr ): self . traveler_name = traveler_name def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"I { self . traveler_name } have travelled enough for now.\" ) print ( f \"I am going to sleep in { context . current_location } ...\" ) print ( \"... zzzZZZzz ...\" )","title":"Stateful Transition Functions"},{"location":"examples/traveler/#custom-state-and-context-setup","text":"As shown in the state machine diagram above we have a state which selects the successor transition based on the weather the user likes and the chosen cities weather. Such a conditional can be implemented by extending the base state and implementing a custom [ State.next(...) ][cr_kyoushi.simulation.states.State.next] method. The below custom state is initialized with the two possible transitions and the desired weather. The next(...) function then simply checks if the desired weather matches the currently chosen cities weather. class DecidingState ( states . State ): def __init__ ( self , name : str , going : transitions . Transition , not_going : transitions . Transition , desired_weather : Weather , ): super () . __init__ ( name , [ going , not_going ]) self . going = going self . not_going = not_going self . desired_weather = desired_weather def next ( self , log : BoundLogger , context : TravelerContext ) -> Optional [ transitions . Transition ]: if context . weather == self . desired_weather : return self . going return self . not_going In addition to our custom state class we also need to extend the base state machine class so we can extend the default state machine [context setup][cr_kyoushi.simulation.sm.Statemachine.setup_context] method. For our example state machine it is enough to simply initialize the traveler context with its default values. class TravelerStatemachine ( sm . Statemachine ): def setup_context ( self ): \"\"\"Initialize traveler context with default values\"\"\" self . context = TravelerContext ()","title":"Custom State and Context Setup"},{"location":"examples/traveler/#transition-and-state-configuration","text":"The final step is to define the state machine factory and implement the [build][cr_kyoushi.simulation.sm.StatemachineFactory.build] method. To define the factory we need to set the factory [name][cr_kyoushi.simulation.sm.StatemachineFactory.name] and the [config class][cr_kyoushi.simulation.sm.StatemachineFactory.config_class]. Important The config class must be set to our config type TravelerConfig Important Also note that for python file state machine factory plugins the factory class must be named StatemachineFactory for the plugin system to detect it correctly! class StatemachineFactory ( sm . StatemachineFactory ): @property def name ( self ) -> str : return \"TravelerStatemachineFactory\" @property def config_class ( self ): return TravelerConfig ... Note If you wish you can also define multiple helper functions for your various build steps. For the purposes of this example we decided to put everything in the main build method. The first thing we will have to do is initialize all our stateful transition functions using the traveler config object that is passed to the build method. def build ( self , config : TravelerConfig ): # Stateful transition functions init # ---------------------------------- say_hello = SayHello ( traveler_name = config . traveler , desired_weather = config . desired_weather , ) select_random_city = SelectRandomCity ( cities = list ( config . cities . keys ())) check_weather_on_map = CheckWeatherMap ( weather_map = config . cities ) sleep_in_city = SleepInCity ( traveler_name = config . traveler ) ... Next create our transition objects by initializing them with their unique names , transition functions and their target state names . We decided to use the [ DelayedTransition ][cr_kyoushi.simulation.transitions.DelayedTransition] for some of our transitions. This special transition type allows us to set pre- and/or post transition execution delays. For our example this will simulate our travelers thought process and the time it takes them to execute some of their actions. Tip As you can see in the code below we use hardcoded strings for the transition and state names. For bigger state machines this can lead to mistakes quickly so we suggest to use centrally defined string constants or enums instead. ... hello = transitions . Transition ( name = \"hello\" , transition_function = say_hello , target = \"selecting_city\" , ) select_city = transitions . DelayedTransition ( name = \"select_city\" , transition_function = select_random_city , target = \"researching\" , delay_after = 3 , ) check_weather = transitions . DelayedTransition ( name = \"check_weather\" , transition_function = check_weather_on_map , target = \"deciding\" , delay_before = 1 , delay_after = 1 , ) going_to_city = transitions . DelayedTransition ( name = \"going_to_city\" , transition_function = goto_city_transition , target = \"traveling\" , delay_after = 10 , ) not_going = transitions . DelayedTransition ( name = \"not_going\" , transition_function = do_not_go_transition , target = \"selecting_city\" , delay_before = 2 , ) arrive_in_city = transitions . Transition ( name = \"arrive\" , transition_function = arrive_transition , target = \"in_city\" , ) going_to_sleep = transitions . DelayedTransition ( name = \"going_to_sleep\" , transition_function = sleep_in_city , target = \"sleeping\" , delay_before = 3.5 , ) ... As final step we have to create our states and initialize the state machine with them. Our traveler state machine uses four different types of states. [ SequentialState ][cr_kyoushi.simulation.states.SequentialState]: This is a simple state that only has one outgoing transition making it easy to define a fixed sequence of states. [ ProbabilisticState ][cr_kyoushi.simulation.states.ProbabilisticState]: This state type allows us to assign a probability to each outgoing transition, it is very useful for defining probabilistic state machines and simulating seemingly random behavior. [ FinalState ][cr_kyoushi.simulation.states.FinalState]: As the name states this is a final state with no outgoing transitions, entering this state will stop the state machine. and our custom DecidingState we defined above. We use a [ ProbabilisticState ][cr_kyoushi.simulation.states.ProbabilisticState] to simulate our traveler getting tired. Each time they reach a new city there is 30% chance of them going to sleep instead of continuing their travels. ... initial = states . SequentialState ( \"initial\" , hello ) selecting_city = states . SequentialState ( \"selecting_city\" , select_city ) researching = states . SequentialState ( \"researching\" , check_weather ) deciding = DecidingState ( \"deciding\" , going = going_to_city , not_going = not_going , desired_weather = config . desired_weather , ) traveling = states . SequentialState ( \"traveling\" , arrive_in_city ) in_city = states . ProbabilisticState ( \"in_city\" , [ going_to_sleep , select_city ], [ 0.3 , 0.7 ] ) sleeping = states . FinalState ( \"sleeping\" ) # Initialize the state machine return TravelerStatemachine ( \"initial\" , [ initial , selecting_city , researching , deciding , traveling , in_city , sleeping , ], )","title":"Transition and State Configuration"},{"location":"examples/traveler/#running-the-example","text":"To run the example state machine you can simply use the Cyber Range Kyoushi CLI. $ cd examples/traveler $ cr-kyoushi-sim -c config.yml run -f traveler.py","title":"Running the Example"},{"location":"reference/config/","text":"Config module \u00b6 \u00b6 FileLogHandler pydantic-model \u00b6 Configuration for a file log handler enabled: bool pydantic-field \u00b6 If the log handler should be enabled or not format: LogFormat pydantic-field \u00b6 The log format to use when logging to the console path: Path pydantic-field \u00b6 The file path to log to, must be set if the handler is enabled. validate_log_path ( path ) classmethod \u00b6 Validate that the given path is a file if it exists Source code in simulation/config.py @validator ( \"path\" ) def validate_log_path ( cls , path : Path ) -> Path : \"\"\"Validate that the given path is a file if it exists\"\"\" if path . exists () and not path . is_file (): raise ValueError ( f \"Log file path { path . absolute () } is not a file!\" ) return path LogFormat \u00b6 Enum for log formatter styles COLORED \u00b6 The same as PLAIN, but colorized JSON \u00b6 The log events in JSON format PLAIN \u00b6 Human readable structured text format LoggingConfig pydantic-model \u00b6 Configuration options for the logging system. console: LogHandler pydantic-field \u00b6 Configuration for the console logger file: FileLogHandler pydantic-field \u00b6 Configuration for the file logger level: LogLevel pydantic-field \u00b6 The log level to use for logging timestamp: LogTimestamp pydantic-field \u00b6 Configuration options for modifying the log timestamps LogHandler pydantic-model \u00b6 Configuration for a log handler enabled: bool pydantic-field \u00b6 If the log handler should be enabled or not format: LogFormat pydantic-field \u00b6 The log format to use when logging to the console LogTimestamp pydantic-model \u00b6 Configuration for the log timestamp format and key format: str pydantic-field \u00b6 The strftime string format to use for formating timestamps (e.g., %Y-%m-%d %H:%M:%S ). If this is None a UNIX timestamp is used. key: str pydantic-field \u00b6 The key to use for the timestamp. utc: bool pydantic-field \u00b6 If the timestamp should be in UTC or the local timezone. PluginConfig pydantic-model \u00b6 Configuration options for the state machine factory plugin system. exclude_names: Pattern pydantic-field \u00b6 A list of regular expressions used to define which plugins to explicitly exclude. include_names: Pattern pydantic-field \u00b6 A list of regular expressions used to define which plugins to include. Settings pydantic-model \u00b6 Cyber Range Kyoushi Simulation settings log: LoggingConfig pydantic-field \u00b6 The logging configuration plugin: PluginConfig pydantic-field \u00b6 The plugin system configuration seed: int pydantic-field \u00b6 The seed to use for random generators configure_seed ( seed = None ) \u00b6 Configure a seed for PRNG, if no seed is passed then one is generated. Parameters: Name Type Description Default seed Optional[int] The seed to use for PRNG None Source code in simulation/config.py def configure_seed ( seed : Optional [ int ] = None ): \"\"\"Configure a seed for PRNG, if no seed is passed then one is generated. Args: seed: The seed to use for PRNG \"\"\" if seed is None : # legacy global numpy requires seeds to be in # [0, 2**32-1] seed = random . randint ( 0 , 2 ** 32 - 1 ) global _SEED _SEED = seed random . seed ( seed ) np . random . seed ( seed ) get_seed () \u00b6 Get the global random seed value for the simulation library Returns: Type Description int The seed value Source code in simulation/config.py def get_seed () -> int : \"\"\"Get the global random seed value for the simulation library Returns: The seed value \"\"\" # configure seed if not already done global _SEED if _SEED is None : configure_seed () # return seed value return _SEED load_config_file ( config_path ) \u00b6 Loads a given a config from the given path and returns a raw dictionary. Supported file formats are: - YAML Parameters: Name Type Description Default config_path Path The file path to read the config from required Returns: Type Description Dict[Any, Any] The contents of the configuration file converted to a dictionary or {} if the file is empty or does not exist. Source code in simulation/config.py def load_config_file ( config_path : Path ) -> Dict [ Any , Any ]: \"\"\"Loads a given a config from the given path and returns a raw dictionary. Supported file formats are: - YAML Args: config_path: The file path to read the config from Returns: The contents of the configuration file converted to a dictionary or `{}` if the file is empty or does not exist. \"\"\" yaml = YAML ( typ = \"safe\" ) if config_path . exists (): return yaml . load ( config_path ) return {} load_settings ( settings_path , log_level = None , seed = None ) \u00b6 Loads the Cyber Range Kyoushi Simulation CLI settings Parameters: Name Type Description Default settings_path Path The path to load the settings file from required log_level Optional[cr_kyoushi.simulation.model.LogLevel] The CLI log_level override. This supercedes the config and environment variable values.. None Exceptions: Type Description ConfigValidationError If the config validation fails Returns: Type Description Settings The validated settings object Source code in simulation/config.py def load_settings ( settings_path : Path , log_level : Optional [ LogLevel ] = None , seed : Optional [ int ] = None , ) -> Settings : \"\"\"Loads the Cyber Range Kyoushi Simulation CLI settings Args: settings_path: The path to load the settings file from log_level: The CLI log_level override. This supercedes the config and environment variable values.. Raises: ConfigValidationError: If the config validation fails Returns: The validated settings object \"\"\" try : settings_raw = load_config_file ( settings_path ) if log_level is not None : settings_raw . setdefault ( \"log\" , {})[ \"level\" ] = log_level if seed is not None : settings_raw [ \"seed\" ] = seed settings = Settings ( _env_file = str ( object ), _env_file_encoding = None , _secrets_dir = None , ** settings_raw , ) return settings except ValidationError as val_err : raise ConfigValidationError ( val_err ) load_sm_config ( config_path , sm_config_type ) \u00b6 Loads and validates the state machine configuration Parameters: Name Type Description Default config_path Path The path to load the configuration from required sm_config_type Type[~StatemachineConfig] The state machine config class to convert to required Exceptions: Type Description ConfigValidationError If the config validation fails Returns: Type Description ~StatemachineConfig The state machine configuration validated and converted to the given config class. Source code in simulation/config.py def load_sm_config ( config_path : Path , sm_config_type : Type [ StatemachineConfig ], ) -> StatemachineConfig : \"\"\"Loads and validates the state machine configuration Args: config_path: The path to load the configuration from sm_config_type: The state machine config class to convert to Raises: ConfigValidationError: If the config validation fails Returns: The state machine configuration validated and converted to the given config class. \"\"\" try : config_raw = load_config_file ( config_path ) if issubclass ( sm_config_type , BaseModel ): return sm_config_type . parse_obj ( config_raw ) else : return config_raw except ValidationError as val_err : raise ConfigValidationError ( val_err )","title":"Configuration"},{"location":"reference/config/#config-module","text":"","title":"Config module"},{"location":"reference/config/#cr_kyoushi.simulation.config","text":"","title":"cr_kyoushi.simulation.config"},{"location":"reference/config/#cr_kyoushi.simulation.config.FileLogHandler","text":"Configuration for a file log handler","title":"FileLogHandler"},{"location":"reference/config/#cr_kyoushi.simulation.config.FileLogHandler.enabled","text":"If the log handler should be enabled or not","title":"enabled"},{"location":"reference/config/#cr_kyoushi.simulation.config.FileLogHandler.format","text":"The log format to use when logging to the console","title":"format"},{"location":"reference/config/#cr_kyoushi.simulation.config.FileLogHandler.path","text":"The file path to log to, must be set if the handler is enabled.","title":"path"},{"location":"reference/config/#cr_kyoushi.simulation.config.FileLogHandler.validate_log_path","text":"Validate that the given path is a file if it exists Source code in simulation/config.py @validator ( \"path\" ) def validate_log_path ( cls , path : Path ) -> Path : \"\"\"Validate that the given path is a file if it exists\"\"\" if path . exists () and not path . is_file (): raise ValueError ( f \"Log file path { path . absolute () } is not a file!\" ) return path","title":"validate_log_path()"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogFormat","text":"Enum for log formatter styles","title":"LogFormat"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogFormat.COLORED","text":"The same as PLAIN, but colorized","title":"COLORED"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogFormat.JSON","text":"The log events in JSON format","title":"JSON"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogFormat.PLAIN","text":"Human readable structured text format","title":"PLAIN"},{"location":"reference/config/#cr_kyoushi.simulation.config.LoggingConfig","text":"Configuration options for the logging system.","title":"LoggingConfig"},{"location":"reference/config/#cr_kyoushi.simulation.config.LoggingConfig.console","text":"Configuration for the console logger","title":"console"},{"location":"reference/config/#cr_kyoushi.simulation.config.LoggingConfig.file","text":"Configuration for the file logger","title":"file"},{"location":"reference/config/#cr_kyoushi.simulation.config.LoggingConfig.level","text":"The log level to use for logging","title":"level"},{"location":"reference/config/#cr_kyoushi.simulation.config.LoggingConfig.timestamp","text":"Configuration options for modifying the log timestamps","title":"timestamp"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogHandler","text":"Configuration for a log handler","title":"LogHandler"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogHandler.enabled","text":"If the log handler should be enabled or not","title":"enabled"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogHandler.format","text":"The log format to use when logging to the console","title":"format"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogTimestamp","text":"Configuration for the log timestamp format and key","title":"LogTimestamp"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogTimestamp.format","text":"The strftime string format to use for formating timestamps (e.g., %Y-%m-%d %H:%M:%S ). If this is None a UNIX timestamp is used.","title":"format"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogTimestamp.key","text":"The key to use for the timestamp.","title":"key"},{"location":"reference/config/#cr_kyoushi.simulation.config.LogTimestamp.utc","text":"If the timestamp should be in UTC or the local timezone.","title":"utc"},{"location":"reference/config/#cr_kyoushi.simulation.config.PluginConfig","text":"Configuration options for the state machine factory plugin system.","title":"PluginConfig"},{"location":"reference/config/#cr_kyoushi.simulation.config.PluginConfig.exclude_names","text":"A list of regular expressions used to define which plugins to explicitly exclude.","title":"exclude_names"},{"location":"reference/config/#cr_kyoushi.simulation.config.PluginConfig.include_names","text":"A list of regular expressions used to define which plugins to include.","title":"include_names"},{"location":"reference/config/#cr_kyoushi.simulation.config.Settings","text":"Cyber Range Kyoushi Simulation settings","title":"Settings"},{"location":"reference/config/#cr_kyoushi.simulation.config.Settings.log","text":"The logging configuration","title":"log"},{"location":"reference/config/#cr_kyoushi.simulation.config.Settings.plugin","text":"The plugin system configuration","title":"plugin"},{"location":"reference/config/#cr_kyoushi.simulation.config.Settings.seed","text":"The seed to use for random generators","title":"seed"},{"location":"reference/config/#cr_kyoushi.simulation.config.configure_seed","text":"Configure a seed for PRNG, if no seed is passed then one is generated. Parameters: Name Type Description Default seed Optional[int] The seed to use for PRNG None Source code in simulation/config.py def configure_seed ( seed : Optional [ int ] = None ): \"\"\"Configure a seed for PRNG, if no seed is passed then one is generated. Args: seed: The seed to use for PRNG \"\"\" if seed is None : # legacy global numpy requires seeds to be in # [0, 2**32-1] seed = random . randint ( 0 , 2 ** 32 - 1 ) global _SEED _SEED = seed random . seed ( seed ) np . random . seed ( seed )","title":"configure_seed()"},{"location":"reference/config/#cr_kyoushi.simulation.config.get_seed","text":"Get the global random seed value for the simulation library Returns: Type Description int The seed value Source code in simulation/config.py def get_seed () -> int : \"\"\"Get the global random seed value for the simulation library Returns: The seed value \"\"\" # configure seed if not already done global _SEED if _SEED is None : configure_seed () # return seed value return _SEED","title":"get_seed()"},{"location":"reference/config/#cr_kyoushi.simulation.config.load_config_file","text":"Loads a given a config from the given path and returns a raw dictionary. Supported file formats are: - YAML Parameters: Name Type Description Default config_path Path The file path to read the config from required Returns: Type Description Dict[Any, Any] The contents of the configuration file converted to a dictionary or {} if the file is empty or does not exist. Source code in simulation/config.py def load_config_file ( config_path : Path ) -> Dict [ Any , Any ]: \"\"\"Loads a given a config from the given path and returns a raw dictionary. Supported file formats are: - YAML Args: config_path: The file path to read the config from Returns: The contents of the configuration file converted to a dictionary or `{}` if the file is empty or does not exist. \"\"\" yaml = YAML ( typ = \"safe\" ) if config_path . exists (): return yaml . load ( config_path ) return {}","title":"load_config_file()"},{"location":"reference/config/#cr_kyoushi.simulation.config.load_settings","text":"Loads the Cyber Range Kyoushi Simulation CLI settings Parameters: Name Type Description Default settings_path Path The path to load the settings file from required log_level Optional[cr_kyoushi.simulation.model.LogLevel] The CLI log_level override. This supercedes the config and environment variable values.. None Exceptions: Type Description ConfigValidationError If the config validation fails Returns: Type Description Settings The validated settings object Source code in simulation/config.py def load_settings ( settings_path : Path , log_level : Optional [ LogLevel ] = None , seed : Optional [ int ] = None , ) -> Settings : \"\"\"Loads the Cyber Range Kyoushi Simulation CLI settings Args: settings_path: The path to load the settings file from log_level: The CLI log_level override. This supercedes the config and environment variable values.. Raises: ConfigValidationError: If the config validation fails Returns: The validated settings object \"\"\" try : settings_raw = load_config_file ( settings_path ) if log_level is not None : settings_raw . setdefault ( \"log\" , {})[ \"level\" ] = log_level if seed is not None : settings_raw [ \"seed\" ] = seed settings = Settings ( _env_file = str ( object ), _env_file_encoding = None , _secrets_dir = None , ** settings_raw , ) return settings except ValidationError as val_err : raise ConfigValidationError ( val_err )","title":"load_settings()"},{"location":"reference/config/#cr_kyoushi.simulation.config.load_sm_config","text":"Loads and validates the state machine configuration Parameters: Name Type Description Default config_path Path The path to load the configuration from required sm_config_type Type[~StatemachineConfig] The state machine config class to convert to required Exceptions: Type Description ConfigValidationError If the config validation fails Returns: Type Description ~StatemachineConfig The state machine configuration validated and converted to the given config class. Source code in simulation/config.py def load_sm_config ( config_path : Path , sm_config_type : Type [ StatemachineConfig ], ) -> StatemachineConfig : \"\"\"Loads and validates the state machine configuration Args: config_path: The path to load the configuration from sm_config_type: The state machine config class to convert to Raises: ConfigValidationError: If the config validation fails Returns: The state machine configuration validated and converted to the given config class. \"\"\" try : config_raw = load_config_file ( config_path ) if issubclass ( sm_config_type , BaseModel ): return sm_config_type . parse_obj ( config_raw ) else : return config_raw except ValidationError as val_err : raise ConfigValidationError ( val_err )","title":"load_sm_config()"},{"location":"reference/errors/","text":"Errors module \u00b6 \u00b6 ConfigValidationError \u00b6 CLI exception indicating that the configuration file was not valid __init__ ( self , cause ) special \u00b6 Parameters: Name Type Description Default cause ValidationError Pydantic validation error that caused validation to fail. required Source code in simulation/errors.py def __init__ ( self , cause : ValidationError ): \"\"\" Args: cause: Pydantic validation error that caused validation to fail. \"\"\" formated_errors = display_errors ( cause . errors ()) super () . __init__ ( f \"Failed to validate the configuration file. \\n { formated_errors } \" ) self . __cause__ = cause SkipSectionError \u00b6 Utility exception to indicate that a task section should be skipped StatemachineFactoryLoadError \u00b6 CLI Exception indicating that a sm factory plugin could not be loaded __init__ ( self , factory_name ) special \u00b6 Parameters: Name Type Description Default factory_name str The name of the factory that failed to load required Source code in simulation/errors.py def __init__ ( self , factory_name : str ): \"\"\" Args: factory_name: The name of the factory that failed to load \"\"\" super () . __init__ ( message = f \"Failed to load sm factory: ' { factory_name } '\" ) StatemachineFactoryTypeError \u00b6 CLI Exception indicating that a type error occurred while loading a sm factory plugin. __init__ ( self , factory_type ) special \u00b6 Parameters: Name Type Description Default factory_type Type The python type of the factory that could not be loaded. required Source code in simulation/errors.py def __init__ ( self , factory_type : Type ): \"\"\" Args: factory_type: The python type of the factory that could not be loaded. \"\"\" super () . __init__ ( message = f \"Failed to load sm factory plugin got invalid type: ' { factory_type } '\" ) TransitionExecutionError \u00b6 Base class for errors that occur during state transitions __init__ ( self , message , cause = None , fallback_state = None ) special \u00b6 Parameters: Name Type Description Default message str The error message required cause Optional[Exception] The underlying cause of the transition error. None fallback_state Optional[str] Optionally the name of the state to fallback to. None Source code in simulation/errors.py def __init__ ( self , message : str , cause : Optional [ Exception ] = None , fallback_state : Optional [ str ] = None , ): \"\"\" Args: message: The error message cause: The underlying cause of the transition error. fallback_state: Optionally the name of the state to fallback to. \"\"\" super () . __init__ ( message ) self . cause = cause self . fallback_state = fallback_state","title":"Exceptions"},{"location":"reference/errors/#errors-module","text":"","title":"Errors module"},{"location":"reference/errors/#cr_kyoushi.simulation.errors","text":"","title":"cr_kyoushi.simulation.errors"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.ConfigValidationError","text":"CLI exception indicating that the configuration file was not valid","title":"ConfigValidationError"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.ConfigValidationError.__init__","text":"Parameters: Name Type Description Default cause ValidationError Pydantic validation error that caused validation to fail. required Source code in simulation/errors.py def __init__ ( self , cause : ValidationError ): \"\"\" Args: cause: Pydantic validation error that caused validation to fail. \"\"\" formated_errors = display_errors ( cause . errors ()) super () . __init__ ( f \"Failed to validate the configuration file. \\n { formated_errors } \" ) self . __cause__ = cause","title":"__init__()"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.SkipSectionError","text":"Utility exception to indicate that a task section should be skipped","title":"SkipSectionError"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.StatemachineFactoryLoadError","text":"CLI Exception indicating that a sm factory plugin could not be loaded","title":"StatemachineFactoryLoadError"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.StatemachineFactoryLoadError.__init__","text":"Parameters: Name Type Description Default factory_name str The name of the factory that failed to load required Source code in simulation/errors.py def __init__ ( self , factory_name : str ): \"\"\" Args: factory_name: The name of the factory that failed to load \"\"\" super () . __init__ ( message = f \"Failed to load sm factory: ' { factory_name } '\" )","title":"__init__()"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.StatemachineFactoryTypeError","text":"CLI Exception indicating that a type error occurred while loading a sm factory plugin.","title":"StatemachineFactoryTypeError"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.StatemachineFactoryTypeError.__init__","text":"Parameters: Name Type Description Default factory_type Type The python type of the factory that could not be loaded. required Source code in simulation/errors.py def __init__ ( self , factory_type : Type ): \"\"\" Args: factory_type: The python type of the factory that could not be loaded. \"\"\" super () . __init__ ( message = f \"Failed to load sm factory plugin got invalid type: ' { factory_type } '\" )","title":"__init__()"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.TransitionExecutionError","text":"Base class for errors that occur during state transitions","title":"TransitionExecutionError"},{"location":"reference/errors/#cr_kyoushi.simulation.errors.TransitionExecutionError.__init__","text":"Parameters: Name Type Description Default message str The error message required cause Optional[Exception] The underlying cause of the transition error. None fallback_state Optional[str] Optionally the name of the state to fallback to. None Source code in simulation/errors.py def __init__ ( self , message : str , cause : Optional [ Exception ] = None , fallback_state : Optional [ str ] = None , ): \"\"\" Args: message: The error message cause: The underlying cause of the transition error. fallback_state: Optionally the name of the state to fallback to. \"\"\" super () . __init__ ( message ) self . cause = cause self . fallback_state = fallback_state","title":"__init__()"},{"location":"reference/logging/","text":"Logging module \u00b6 \u00b6 encoder \u00b6 Custom encoder based on the pydantic encoder with additional types enabled. (see JSON_ENCODERS ) Note This is necessary since the Pydantic JSON encoder cannot handle Pattern fields as of v1.7.3. The code exists already on the master branch and should be part of the next release. LOGGER_NAME \u00b6 The name of the Cyber Range Kyoushi Simulation logger configure_logging ( logging_config ) \u00b6 Configures the logging system based on the passed [ LoggingConfig ][cr_kyoushi.simulation.config.LoggingConfig] Parameters: Name Type Description Default logging_config LoggingConfig The logging configuration object required Source code in simulation/logging.py def configure_logging ( logging_config : LoggingConfig ): \"\"\"Configures the logging system based on the passed [`LoggingConfig`][cr_kyoushi.simulation.config.LoggingConfig] Args: logging_config: The logging configuration object \"\"\" # ensure we start from default config structlog . reset_defaults () timestamper = structlog . processors . TimeStamper ( fmt = logging_config . timestamp . format , utc = logging_config . timestamp . utc , key = logging_config . timestamp . key , ) # shared processors for standard lib and structlog shared_processors : List [ Callable [ [ Any , str , MutableMapping [ str , Any ]], Union [ Mapping [ str , Any ], str , bytes , Tuple [ Any , ... ]], ] ] = [ structlog . stdlib . add_log_level , timestamper , structlog . stdlib . PositionalArgumentsFormatter (), structlog . processors . StackInfoRenderer (), structlog . processors . format_exc_info , ] # processor only for structlog processors : List [ Callable [ [ Any , str , MutableMapping [ str , Any ]], Union [ Mapping [ str , Any ], str , bytes , Tuple [ Any , ... ]], ] ] = [ structlog . stdlib . filter_by_level ] processors . extend ( shared_processors ) # the processor formatter wrapper must be last as it changes the processors . append ( structlog . stdlib . ProcessorFormatter . wrap_for_formatter ) handlers = {} # configure console logging if logging_config . console . enabled : handlers [ \"console\" ] = { \"level\" : \"DEBUG\" , \"class\" : \"logging.StreamHandler\" , \"formatter\" : logging_config . console . format , } # configure file logging if logging_config . file . enabled : handlers [ \"file\" ] = { \"level\" : \"DEBUG\" , \"class\" : \"logging.handlers.WatchedFileHandler\" , \"filename\" : str ( logging_config . file . path . absolute ()), \"formatter\" : logging_config . file . format , } # configure standard lib logging logging . config . dictConfig ( { \"version\" : 1 , \"disable_existing_loggers\" : False , \"formatters\" : { LogFormat . PLAIN : { \"()\" : structlog . stdlib . ProcessorFormatter , \"processor\" : structlog . dev . ConsoleRenderer ( colors = False ), \"foreign_pre_chain\" : shared_processors , }, LogFormat . COLORED : { \"()\" : structlog . stdlib . ProcessorFormatter , \"processor\" : structlog . dev . ConsoleRenderer ( colors = True ), \"foreign_pre_chain\" : shared_processors , }, LogFormat . JSON : { \"()\" : structlog . stdlib . ProcessorFormatter , # when logging to json we rename the \"event\" field to \"message\" \"processor\" : rename_event_key_wrapper ( structlog . processors . JSONRenderer ( serializer = json . dumps , sort_keys = True , default = encoder , ) ), \"foreign_pre_chain\" : shared_processors , }, }, \"handlers\" : handlers , \"loggers\" : { LOGGER_NAME : { \"handlers\" : handlers . keys (), \"propagate\" : True }}, } ) # apply structlog config structlog . configure ( processors = processors , context_class = dict , logger_factory = structlog . stdlib . LoggerFactory (), wrapper_class = structlog . stdlib . BoundLogger , cache_logger_on_first_use = True , ) # set the log level logger = structlog . get_logger ( LOGGER_NAME ) logger . setLevel ( logging_config . level ) get_logger () \u00b6 Convenience function for getting the Cyber Range Kyoushi Simulation logger. Source code in simulation/logging.py def get_logger () -> structlog . stdlib . BoundLogger : \"\"\"Convenience function for getting the Cyber Range Kyoushi Simulation logger.\"\"\" return structlog . stdlib . get_logger ( LOGGER_NAME ) rename_event_key ( logger , method_name , event_dict , field_name ) \u00b6 Processor for renaming the event key to message. We do this since this is more compatible with the ecs schema. Source code in simulation/logging.py def rename_event_key ( logger : logging . Logger , method_name : str , event_dict : MutableMapping [ str , Any ], field_name : str , ) -> MutableMapping [ str , Any ]: \"\"\"Processor for renaming the event key to message. We do this since this is more compatible with the ecs schema. \"\"\" event_dict [ field_name ] = event_dict . pop ( \"event\" ) return event_dict rename_event_key_wrapper ( func , field_name = 'message' ) \u00b6 Processor wrapper that renames the event field before calling the given processor. Parameters: Name Type Description Default func Callable[[logging.Logger, str, MutableMapping[str, Any]], Any] The processor to be wrapped required field_name str The field name to use instead of event 'message' Returns: Type Description Callable[[logging.Logger, str, MutableMapping[str, Any]], MutableMapping[str, Any]] The wrapped processor Source code in simulation/logging.py def rename_event_key_wrapper ( func : Callable [[ logging . Logger , str , MutableMapping [ str , Any ]], Any ], field_name : str = \"message\" , ) -> Callable [ [ logging . Logger , str , MutableMapping [ str , Any ]], MutableMapping [ str , Any ] ]: \"\"\"Processor wrapper that renames the event field before calling the given processor. Args: func: The processor to be wrapped field_name: The field name to use instead of `event` Returns: The wrapped processor \"\"\" def _rename_event_key ( logger : logging . Logger , method_name : str , event_dict : MutableMapping [ str , Any ] ) -> MutableMapping [ str , Any ]: event_dict = rename_event_key ( logger , method_name , event_dict , field_name ) return func ( logger , method_name , event_dict ) return _rename_event_key","title":"Logging"},{"location":"reference/logging/#logging-module","text":"","title":"Logging module"},{"location":"reference/logging/#cr_kyoushi.simulation.logging","text":"","title":"cr_kyoushi.simulation.logging"},{"location":"reference/logging/#cr_kyoushi.simulation.logging.encoder","text":"Custom encoder based on the pydantic encoder with additional types enabled. (see JSON_ENCODERS ) Note This is necessary since the Pydantic JSON encoder cannot handle Pattern fields as of v1.7.3. The code exists already on the master branch and should be part of the next release.","title":"encoder"},{"location":"reference/logging/#cr_kyoushi.simulation.logging.LOGGER_NAME","text":"The name of the Cyber Range Kyoushi Simulation logger","title":"LOGGER_NAME"},{"location":"reference/logging/#cr_kyoushi.simulation.logging.configure_logging","text":"Configures the logging system based on the passed [ LoggingConfig ][cr_kyoushi.simulation.config.LoggingConfig] Parameters: Name Type Description Default logging_config LoggingConfig The logging configuration object required Source code in simulation/logging.py def configure_logging ( logging_config : LoggingConfig ): \"\"\"Configures the logging system based on the passed [`LoggingConfig`][cr_kyoushi.simulation.config.LoggingConfig] Args: logging_config: The logging configuration object \"\"\" # ensure we start from default config structlog . reset_defaults () timestamper = structlog . processors . TimeStamper ( fmt = logging_config . timestamp . format , utc = logging_config . timestamp . utc , key = logging_config . timestamp . key , ) # shared processors for standard lib and structlog shared_processors : List [ Callable [ [ Any , str , MutableMapping [ str , Any ]], Union [ Mapping [ str , Any ], str , bytes , Tuple [ Any , ... ]], ] ] = [ structlog . stdlib . add_log_level , timestamper , structlog . stdlib . PositionalArgumentsFormatter (), structlog . processors . StackInfoRenderer (), structlog . processors . format_exc_info , ] # processor only for structlog processors : List [ Callable [ [ Any , str , MutableMapping [ str , Any ]], Union [ Mapping [ str , Any ], str , bytes , Tuple [ Any , ... ]], ] ] = [ structlog . stdlib . filter_by_level ] processors . extend ( shared_processors ) # the processor formatter wrapper must be last as it changes the processors . append ( structlog . stdlib . ProcessorFormatter . wrap_for_formatter ) handlers = {} # configure console logging if logging_config . console . enabled : handlers [ \"console\" ] = { \"level\" : \"DEBUG\" , \"class\" : \"logging.StreamHandler\" , \"formatter\" : logging_config . console . format , } # configure file logging if logging_config . file . enabled : handlers [ \"file\" ] = { \"level\" : \"DEBUG\" , \"class\" : \"logging.handlers.WatchedFileHandler\" , \"filename\" : str ( logging_config . file . path . absolute ()), \"formatter\" : logging_config . file . format , } # configure standard lib logging logging . config . dictConfig ( { \"version\" : 1 , \"disable_existing_loggers\" : False , \"formatters\" : { LogFormat . PLAIN : { \"()\" : structlog . stdlib . ProcessorFormatter , \"processor\" : structlog . dev . ConsoleRenderer ( colors = False ), \"foreign_pre_chain\" : shared_processors , }, LogFormat . COLORED : { \"()\" : structlog . stdlib . ProcessorFormatter , \"processor\" : structlog . dev . ConsoleRenderer ( colors = True ), \"foreign_pre_chain\" : shared_processors , }, LogFormat . JSON : { \"()\" : structlog . stdlib . ProcessorFormatter , # when logging to json we rename the \"event\" field to \"message\" \"processor\" : rename_event_key_wrapper ( structlog . processors . JSONRenderer ( serializer = json . dumps , sort_keys = True , default = encoder , ) ), \"foreign_pre_chain\" : shared_processors , }, }, \"handlers\" : handlers , \"loggers\" : { LOGGER_NAME : { \"handlers\" : handlers . keys (), \"propagate\" : True }}, } ) # apply structlog config structlog . configure ( processors = processors , context_class = dict , logger_factory = structlog . stdlib . LoggerFactory (), wrapper_class = structlog . stdlib . BoundLogger , cache_logger_on_first_use = True , ) # set the log level logger = structlog . get_logger ( LOGGER_NAME ) logger . setLevel ( logging_config . level )","title":"configure_logging()"},{"location":"reference/logging/#cr_kyoushi.simulation.logging.get_logger","text":"Convenience function for getting the Cyber Range Kyoushi Simulation logger. Source code in simulation/logging.py def get_logger () -> structlog . stdlib . BoundLogger : \"\"\"Convenience function for getting the Cyber Range Kyoushi Simulation logger.\"\"\" return structlog . stdlib . get_logger ( LOGGER_NAME )","title":"get_logger()"},{"location":"reference/logging/#cr_kyoushi.simulation.logging.rename_event_key","text":"Processor for renaming the event key to message. We do this since this is more compatible with the ecs schema. Source code in simulation/logging.py def rename_event_key ( logger : logging . Logger , method_name : str , event_dict : MutableMapping [ str , Any ], field_name : str , ) -> MutableMapping [ str , Any ]: \"\"\"Processor for renaming the event key to message. We do this since this is more compatible with the ecs schema. \"\"\" event_dict [ field_name ] = event_dict . pop ( \"event\" ) return event_dict","title":"rename_event_key()"},{"location":"reference/logging/#cr_kyoushi.simulation.logging.rename_event_key_wrapper","text":"Processor wrapper that renames the event field before calling the given processor. Parameters: Name Type Description Default func Callable[[logging.Logger, str, MutableMapping[str, Any]], Any] The processor to be wrapped required field_name str The field name to use instead of event 'message' Returns: Type Description Callable[[logging.Logger, str, MutableMapping[str, Any]], MutableMapping[str, Any]] The wrapped processor Source code in simulation/logging.py def rename_event_key_wrapper ( func : Callable [[ logging . Logger , str , MutableMapping [ str , Any ]], Any ], field_name : str = \"message\" , ) -> Callable [ [ logging . Logger , str , MutableMapping [ str , Any ]], MutableMapping [ str , Any ] ]: \"\"\"Processor wrapper that renames the event field before calling the given processor. Args: func: The processor to be wrapped field_name: The field name to use instead of `event` Returns: The wrapped processor \"\"\" def _rename_event_key ( logger : logging . Logger , method_name : str , event_dict : MutableMapping [ str , Any ] ) -> MutableMapping [ str , Any ]: event_dict = rename_event_key ( logger , method_name , event_dict , field_name ) return func ( logger , method_name , event_dict ) return _rename_event_key","title":"rename_event_key_wrapper()"},{"location":"reference/model/","text":"Model module \u00b6 \u00b6 Context \u00b6 Contexts are used to store the state machine execution context. They can either be a custom defined pydantic model or Dict[str, Any] . StatemachineConfig \u00b6 Placeholder generic type for state machine configurations. ActivePeriod pydantic-model \u00b6 Active period union type. This class can be used in pydantic models to allow loading of [ ComplexActivePeriod ][cr_kyoushi.simulation.model.ComplexActivePeriod] or [ SimpleActivePeriod ][cr_kyoushi.simulation.model.SimpleActivePeriod]. in_active_period ( self , to_check ) \u00b6 Checks wether the given datetime is within this active period. The actual check is delegated to the underlying sub types own checking logic. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within this active period. The actual check is delegated to the underlying sub types own checking logic. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return self . __root__ . in_active_period ( to_check ) ApproximateFloat pydantic-model \u00b6 Approximate float value within a given open interval max: float pydantic-field required \u00b6 The upper boundary for the float value min: float pydantic-field required \u00b6 The lower boundary for the float value value: float property readonly \u00b6 Gets a random float within the approximate float range Returns: Type Description float A float x for which min <= x <= max convert ( value ) classmethod \u00b6 Coerces a single float value to its ApproximateFloat equivalent. i.e., value = min = max Parameters: Name Type Description Default value float The float value to convert required Returns: Type Description ApproximateFloat Approximate(min=value, max=value) Source code in simulation/model.py @classmethod def convert ( cls , value : float ) -> \"ApproximateFloat\" : \"\"\"Coerces a single float value to its ApproximateFloat equivalent. i.e., value = min = max Args: value: The float value to convert Returns: `Approximate(min=value, max=value)` \"\"\" return ApproximateFloat ( min = value , max = value ) validate_min_le_max ( v , values , ** kwargs ) classmethod \u00b6 Custom validator to ensure min <= max Source code in simulation/model.py @validator ( \"max\" ) def validate_min_le_max ( cls , v : float , values , ** kwargs ) -> float : \"\"\"Custom validator to ensure min <= max\"\"\" assert values [ \"min\" ] <= v , \"Invalid boundaries must be min <= max\" return v ComplexActivePeriod pydantic-model \u00b6 A ComplexActivePeriod is defined by a set of [ WeekdayActivePeriod ][cr_kyoushi.simulation.model.WeekdayActivePeriod]. This makes it possible to configure active times for each week day separately. week_days: WeekdayActivePeriod pydantic-field required \u00b6 Set of active periods, each week day can only have one configuration in_active_period ( self , to_check ) \u00b6 Checks wether the given datetime is within this active period. This is True if the datetime is within the scope of one of the [ WeekdayActivePeriods ][cr_kyoushi.simulation.model.WeekdayActivePeriod]. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within this active period. This is `True` if the datetime is within the scope of **one** of the [`WeekdayActivePeriods`][cr_kyoushi.simulation.model.WeekdayActivePeriod]. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return any ( period . in_active_period ( to_check ) for period in self . week_days ) LogLevel \u00b6 An enumeration. SimpleActivePeriod pydantic-model \u00b6 Similar to [ ComplexActivePeriod ][cr_kyoushi.simulation.model.ComplexActivePeriod], but each week day has the same active time period. time_period: TimePeriod pydantic-field \u00b6 The daylie active time period (if this is not set the whole days are considered active). week_days: Weekday pydantic-field required \u00b6 A set of active week days. in_active_period ( self , to_check ) \u00b6 Checks wether the given datetime is within this active period. This is True if the datetime matches one of the active week days and the active time period. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within this active period. This is `True` if the datetime matches **one** of the active week days and the active time period. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return Weekday ( to_check . weekday ()) in self . week_days and ( self . time_period is None or self . time_period . in_period ( to_check . time ()) ) TimePeriod pydantic-model \u00b6 A time period as defined by a start and end time. end_time: time pydantic-field required \u00b6 The end time of the period start_time: time pydantic-field required \u00b6 The start time of the period in_period ( self , to_check ) \u00b6 Checks wether the given time of the day is within the scope of this time period. Parameters: Name Type Description Default to_check time The time of the day to check required Returns: Type Description bool bool: True if within the time period False otherwise Source code in simulation/model.py def in_period ( self , to_check : time ) -> bool : \"\"\"Checks wether the given time of the day is within the scope of this time period. Args: to_check (time): The time of the day to check Returns: bool: `True` if within the time period `False` otherwise \"\"\" if self . start_time <= self . end_time : return self . start_time <= to_check and self . end_time > to_check # start > end means our time period is between two days return self . start_time <= to_check or self . end_time > to_check Weekday \u00b6 Enumeration for representing the days of the week. Weekdays are represented as the integers 0-6 and can be constructed from either their int representations or their english names. WeekdayActivePeriod pydantic-model \u00b6 A WeekdayActivePeriod defines its active time based on the configure week day and time period. time_period: TimePeriod pydantic-field \u00b6 The active time period (if this is not set the whole day is considered active) week_day: Weekday pydantic-field required \u00b6 The active day of the week __eq__ ( self , other ) special \u00b6 Return self==value. Source code in simulation/model.py def __eq__ ( self , other ) -> bool : return self . __class__ == other . __class__ and self . week_day == other . week_day __hash__ ( self ) special \u00b6 Return hash(self). Source code in simulation/model.py def __hash__ ( self ): return hash ( self . week_day ) in_active_period ( self , to_check ) \u00b6 Checks wether the given datetime is within the scope of this active period. This will be True if the week day matches and given time of the day is within the time period. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within the scope of this active period. This will be True if the week day matches and given time of the day is within the time period. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return Weekday ( to_check . weekday ()) is self . week_day and ( self . time_period is None or self . time_period . in_period ( to_check . time ()) ) WorkHours pydantic-model \u00b6 A special type of time period that does not allow over night periods validate_start_before_end ( v , values , ** kwargs ) classmethod \u00b6 Validates that the start time is before the end time. This restricts work hours to be within a single day i.e., work hours can not be defined to start on one day and end on the following day. Parameters: Name Type Description Default v time The parsed end time to check required values Dict[str, Any] A dictionary containing previously parsed and validated fields. See Pydantic for details. required Returns: Type Description time The end time if it is valid Source code in simulation/model.py @validator ( \"end_time\" ) def validate_start_before_end ( cls , v : time , values : Dict [ str , Any ], ** kwargs , ) -> time : \"\"\"Validates that the start time is before the end time. This restricts work hours to be within a single day i.e., work hours can not be defined to start on one day and end on the following day. Args: v: The parsed end time to check values: A dictionary containing previously parsed and validated fields. See [Pydantic](https://pydantic-docs.helpmanual.io/usage/validators/) for details. Returns: The end time if it is valid \"\"\" # if start time is not in values it failed to validate # so we skip the check and let validation fail if \"start_time\" in values : assert values [ \"start_time\" ] < v , \"End time must be after start time\" return v WorkSchedule pydantic-model \u00b6 A weekly work schedule represented by the week days and work hours for each day work_days: WorkHours pydantic-field required \u00b6 Dictionary containing the work hours for each weekday is_work_day ( self , weekday ) \u00b6 Checks wether the given weekday is a work day. Parameters: Name Type Description Default weekday Weekday The weekday to check encoded as integer (0-6) required Returns: Type Description bool True if it is a work day False otherwise Source code in simulation/model.py def is_work_day ( self , weekday : Weekday ) -> bool : \"\"\"Checks wether the given weekday is a work day. Args: weekday: The weekday to check encoded as integer (0-6) Returns: `True` if it is a work day `False` otherwise \"\"\" return weekday in self . work_days is_work_time ( self , to_check ) \u00b6 Checks wether the given datetime is work time. Something is considered to be work time if it is a work day and the time is within the work hours of that work day. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool True if the given datetime is work time False otherwise Source code in simulation/model.py def is_work_time ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is work time. Something is considered to be work time if it is a work day and the time is within the work hours of that work day. Args: to_check: The datetime to check Returns: `True` if the given datetime is work time `False` otherwise \"\"\" weekday : Weekday = Weekday ( to_check . weekday ()) # check if the datetime is on a work day if self . is_work_day ( weekday ): # if its on a workday check if its with the days work hours return self . work_days [ weekday ] . in_period ( to_check . time ()) return False next_work_start ( self , to_check ) \u00b6 Gets the next work time, relative to the given datetime. If the given datetime is within work hours the start time of that work day is returned. Parameters: Name Type Description Default to_check datetime The datetime to find the next work time for required Returns: Type Description Optional[datetime.datetime] The next work time or None if there is no work time Source code in simulation/model.py def next_work_start ( self , to_check : datetime ) -> Optional [ datetime ]: \"\"\"Gets the next work time, relative to the given datetime. If the given datetime is within work hours the start time of that work day is returned. Args: to_check: The datetime to find the next work time for Returns: The next work time or `None` if there is no work time \"\"\" weekday : Weekday = Weekday ( to_check . weekday ()) if ( # if the given datetime is a workday self . is_work_day ( weekday ) and ( # and work has not begun yet to_check . time () <= self . work_days [ weekday ] . start_time # or if we are still within work time # we return the given days start time or self . is_work_time ( to_check ) ) ): return datetime . combine ( to_check . date (), self . work_days [ weekday ] . start_time ) # otherwise next work start must be some day after # the given day so we check the next 7 days # (we might only work once a week) for i in range ( 1 , 8 ): # increment weekday and be sure to start from 0 once we pass sunday (int: 6) weekday = Weekday (( weekday + 1 ) % 7 ) if self . is_work_day ( weekday ): # add the days till the next work day to the given date next_work : datetime = to_check + timedelta ( i ) # get the start time for that day start_time = self . work_days [ weekday ] . start_time return datetime . combine ( next_work . date (), start_time ) # if we got here then no workday is set so we will never start return None","title":"Models"},{"location":"reference/model/#model-module","text":"","title":"Model module"},{"location":"reference/model/#cr_kyoushi.simulation.model","text":"","title":"cr_kyoushi.simulation.model"},{"location":"reference/model/#cr_kyoushi.simulation.model.Context","text":"Contexts are used to store the state machine execution context. They can either be a custom defined pydantic model or Dict[str, Any] .","title":"Context"},{"location":"reference/model/#cr_kyoushi.simulation.model.StatemachineConfig","text":"Placeholder generic type for state machine configurations.","title":"StatemachineConfig"},{"location":"reference/model/#cr_kyoushi.simulation.model.ActivePeriod","text":"Active period union type. This class can be used in pydantic models to allow loading of [ ComplexActivePeriod ][cr_kyoushi.simulation.model.ComplexActivePeriod] or [ SimpleActivePeriod ][cr_kyoushi.simulation.model.SimpleActivePeriod].","title":"ActivePeriod"},{"location":"reference/model/#cr_kyoushi.simulation.model.ActivePeriod.in_active_period","text":"Checks wether the given datetime is within this active period. The actual check is delegated to the underlying sub types own checking logic. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within this active period. The actual check is delegated to the underlying sub types own checking logic. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return self . __root__ . in_active_period ( to_check )","title":"in_active_period()"},{"location":"reference/model/#cr_kyoushi.simulation.model.ApproximateFloat","text":"Approximate float value within a given open interval","title":"ApproximateFloat"},{"location":"reference/model/#cr_kyoushi.simulation.model.ApproximateFloat.max","text":"The upper boundary for the float value","title":"max"},{"location":"reference/model/#cr_kyoushi.simulation.model.ApproximateFloat.min","text":"The lower boundary for the float value","title":"min"},{"location":"reference/model/#cr_kyoushi.simulation.model.ApproximateFloat.value","text":"Gets a random float within the approximate float range Returns: Type Description float A float x for which min <= x <= max","title":"value"},{"location":"reference/model/#cr_kyoushi.simulation.model.ApproximateFloat.convert","text":"Coerces a single float value to its ApproximateFloat equivalent. i.e., value = min = max Parameters: Name Type Description Default value float The float value to convert required Returns: Type Description ApproximateFloat Approximate(min=value, max=value) Source code in simulation/model.py @classmethod def convert ( cls , value : float ) -> \"ApproximateFloat\" : \"\"\"Coerces a single float value to its ApproximateFloat equivalent. i.e., value = min = max Args: value: The float value to convert Returns: `Approximate(min=value, max=value)` \"\"\" return ApproximateFloat ( min = value , max = value )","title":"convert()"},{"location":"reference/model/#cr_kyoushi.simulation.model.ApproximateFloat.validate_min_le_max","text":"Custom validator to ensure min <= max Source code in simulation/model.py @validator ( \"max\" ) def validate_min_le_max ( cls , v : float , values , ** kwargs ) -> float : \"\"\"Custom validator to ensure min <= max\"\"\" assert values [ \"min\" ] <= v , \"Invalid boundaries must be min <= max\" return v","title":"validate_min_le_max()"},{"location":"reference/model/#cr_kyoushi.simulation.model.ComplexActivePeriod","text":"A ComplexActivePeriod is defined by a set of [ WeekdayActivePeriod ][cr_kyoushi.simulation.model.WeekdayActivePeriod]. This makes it possible to configure active times for each week day separately.","title":"ComplexActivePeriod"},{"location":"reference/model/#cr_kyoushi.simulation.model.ComplexActivePeriod.week_days","text":"Set of active periods, each week day can only have one configuration","title":"week_days"},{"location":"reference/model/#cr_kyoushi.simulation.model.ComplexActivePeriod.in_active_period","text":"Checks wether the given datetime is within this active period. This is True if the datetime is within the scope of one of the [ WeekdayActivePeriods ][cr_kyoushi.simulation.model.WeekdayActivePeriod]. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within this active period. This is `True` if the datetime is within the scope of **one** of the [`WeekdayActivePeriods`][cr_kyoushi.simulation.model.WeekdayActivePeriod]. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return any ( period . in_active_period ( to_check ) for period in self . week_days )","title":"in_active_period()"},{"location":"reference/model/#cr_kyoushi.simulation.model.LogLevel","text":"An enumeration.","title":"LogLevel"},{"location":"reference/model/#cr_kyoushi.simulation.model.SimpleActivePeriod","text":"Similar to [ ComplexActivePeriod ][cr_kyoushi.simulation.model.ComplexActivePeriod], but each week day has the same active time period.","title":"SimpleActivePeriod"},{"location":"reference/model/#cr_kyoushi.simulation.model.SimpleActivePeriod.time_period","text":"The daylie active time period (if this is not set the whole days are considered active).","title":"time_period"},{"location":"reference/model/#cr_kyoushi.simulation.model.SimpleActivePeriod.week_days","text":"A set of active week days.","title":"week_days"},{"location":"reference/model/#cr_kyoushi.simulation.model.SimpleActivePeriod.in_active_period","text":"Checks wether the given datetime is within this active period. This is True if the datetime matches one of the active week days and the active time period. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within this active period. This is `True` if the datetime matches **one** of the active week days and the active time period. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return Weekday ( to_check . weekday ()) in self . week_days and ( self . time_period is None or self . time_period . in_period ( to_check . time ()) )","title":"in_active_period()"},{"location":"reference/model/#cr_kyoushi.simulation.model.TimePeriod","text":"A time period as defined by a start and end time.","title":"TimePeriod"},{"location":"reference/model/#cr_kyoushi.simulation.model.TimePeriod.end_time","text":"The end time of the period","title":"end_time"},{"location":"reference/model/#cr_kyoushi.simulation.model.TimePeriod.start_time","text":"The start time of the period","title":"start_time"},{"location":"reference/model/#cr_kyoushi.simulation.model.TimePeriod.in_period","text":"Checks wether the given time of the day is within the scope of this time period. Parameters: Name Type Description Default to_check time The time of the day to check required Returns: Type Description bool bool: True if within the time period False otherwise Source code in simulation/model.py def in_period ( self , to_check : time ) -> bool : \"\"\"Checks wether the given time of the day is within the scope of this time period. Args: to_check (time): The time of the day to check Returns: bool: `True` if within the time period `False` otherwise \"\"\" if self . start_time <= self . end_time : return self . start_time <= to_check and self . end_time > to_check # start > end means our time period is between two days return self . start_time <= to_check or self . end_time > to_check","title":"in_period()"},{"location":"reference/model/#cr_kyoushi.simulation.model.Weekday","text":"Enumeration for representing the days of the week. Weekdays are represented as the integers 0-6 and can be constructed from either their int representations or their english names.","title":"Weekday"},{"location":"reference/model/#cr_kyoushi.simulation.model.WeekdayActivePeriod","text":"A WeekdayActivePeriod defines its active time based on the configure week day and time period.","title":"WeekdayActivePeriod"},{"location":"reference/model/#cr_kyoushi.simulation.model.WeekdayActivePeriod.time_period","text":"The active time period (if this is not set the whole day is considered active)","title":"time_period"},{"location":"reference/model/#cr_kyoushi.simulation.model.WeekdayActivePeriod.week_day","text":"The active day of the week","title":"week_day"},{"location":"reference/model/#cr_kyoushi.simulation.model.WeekdayActivePeriod.__eq__","text":"Return self==value. Source code in simulation/model.py def __eq__ ( self , other ) -> bool : return self . __class__ == other . __class__ and self . week_day == other . week_day","title":"__eq__()"},{"location":"reference/model/#cr_kyoushi.simulation.model.WeekdayActivePeriod.__hash__","text":"Return hash(self). Source code in simulation/model.py def __hash__ ( self ): return hash ( self . week_day )","title":"__hash__()"},{"location":"reference/model/#cr_kyoushi.simulation.model.WeekdayActivePeriod.in_active_period","text":"Checks wether the given datetime is within the scope of this active period. This will be True if the week day matches and given time of the day is within the time period. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool bool: True if inside the active period False otherwise Source code in simulation/model.py def in_active_period ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is within the scope of this active period. This will be True if the week day matches and given time of the day is within the time period. Args: to_check (datetime): The datetime to check Returns: bool: `True` if inside the active period `False` otherwise \"\"\" return Weekday ( to_check . weekday ()) is self . week_day and ( self . time_period is None or self . time_period . in_period ( to_check . time ()) )","title":"in_active_period()"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkHours","text":"A special type of time period that does not allow over night periods","title":"WorkHours"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkHours.validate_start_before_end","text":"Validates that the start time is before the end time. This restricts work hours to be within a single day i.e., work hours can not be defined to start on one day and end on the following day. Parameters: Name Type Description Default v time The parsed end time to check required values Dict[str, Any] A dictionary containing previously parsed and validated fields. See Pydantic for details. required Returns: Type Description time The end time if it is valid Source code in simulation/model.py @validator ( \"end_time\" ) def validate_start_before_end ( cls , v : time , values : Dict [ str , Any ], ** kwargs , ) -> time : \"\"\"Validates that the start time is before the end time. This restricts work hours to be within a single day i.e., work hours can not be defined to start on one day and end on the following day. Args: v: The parsed end time to check values: A dictionary containing previously parsed and validated fields. See [Pydantic](https://pydantic-docs.helpmanual.io/usage/validators/) for details. Returns: The end time if it is valid \"\"\" # if start time is not in values it failed to validate # so we skip the check and let validation fail if \"start_time\" in values : assert values [ \"start_time\" ] < v , \"End time must be after start time\" return v","title":"validate_start_before_end()"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkSchedule","text":"A weekly work schedule represented by the week days and work hours for each day","title":"WorkSchedule"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkSchedule.work_days","text":"Dictionary containing the work hours for each weekday","title":"work_days"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkSchedule.is_work_day","text":"Checks wether the given weekday is a work day. Parameters: Name Type Description Default weekday Weekday The weekday to check encoded as integer (0-6) required Returns: Type Description bool True if it is a work day False otherwise Source code in simulation/model.py def is_work_day ( self , weekday : Weekday ) -> bool : \"\"\"Checks wether the given weekday is a work day. Args: weekday: The weekday to check encoded as integer (0-6) Returns: `True` if it is a work day `False` otherwise \"\"\" return weekday in self . work_days","title":"is_work_day()"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkSchedule.is_work_time","text":"Checks wether the given datetime is work time. Something is considered to be work time if it is a work day and the time is within the work hours of that work day. Parameters: Name Type Description Default to_check datetime The datetime to check required Returns: Type Description bool True if the given datetime is work time False otherwise Source code in simulation/model.py def is_work_time ( self , to_check : datetime ) -> bool : \"\"\"Checks wether the given datetime is work time. Something is considered to be work time if it is a work day and the time is within the work hours of that work day. Args: to_check: The datetime to check Returns: `True` if the given datetime is work time `False` otherwise \"\"\" weekday : Weekday = Weekday ( to_check . weekday ()) # check if the datetime is on a work day if self . is_work_day ( weekday ): # if its on a workday check if its with the days work hours return self . work_days [ weekday ] . in_period ( to_check . time ()) return False","title":"is_work_time()"},{"location":"reference/model/#cr_kyoushi.simulation.model.WorkSchedule.next_work_start","text":"Gets the next work time, relative to the given datetime. If the given datetime is within work hours the start time of that work day is returned. Parameters: Name Type Description Default to_check datetime The datetime to find the next work time for required Returns: Type Description Optional[datetime.datetime] The next work time or None if there is no work time Source code in simulation/model.py def next_work_start ( self , to_check : datetime ) -> Optional [ datetime ]: \"\"\"Gets the next work time, relative to the given datetime. If the given datetime is within work hours the start time of that work day is returned. Args: to_check: The datetime to find the next work time for Returns: The next work time or `None` if there is no work time \"\"\" weekday : Weekday = Weekday ( to_check . weekday ()) if ( # if the given datetime is a workday self . is_work_day ( weekday ) and ( # and work has not begun yet to_check . time () <= self . work_days [ weekday ] . start_time # or if we are still within work time # we return the given days start time or self . is_work_time ( to_check ) ) ): return datetime . combine ( to_check . date (), self . work_days [ weekday ] . start_time ) # otherwise next work start must be some day after # the given day so we check the next 7 days # (we might only work once a week) for i in range ( 1 , 8 ): # increment weekday and be sure to start from 0 once we pass sunday (int: 6) weekday = Weekday (( weekday + 1 ) % 7 ) if self . is_work_day ( weekday ): # add the days till the next work day to the given date next_work : datetime = to_check + timedelta ( i ) # get the start time for that day start_time = self . work_days [ weekday ] . start_time return datetime . combine ( next_work . date (), start_time ) # if we got here then no workday is set so we will never start return None","title":"next_work_start()"},{"location":"reference/sm/","text":"Statemachine module \u00b6 \u00b6 State machine module This module contains all class and function defintions for creating and defining Cyber Range Kyoushi simulation machines. StartEndTimeStatemachine \u00b6 Special type of state machine that allows configuring a start and end time. The main stat machine execution loop will only start execution once it is the configured start time (starts immediately if none is configured). Similarly the state machine will stop once the current time is the end time even if there are still transitions left to execute. This is for example useful when you wish to configure a state machine to only run for the duration of an experiment. Note A state machine might end before its end time if it enters a final state. context: Union [ pydantic . main . BaseModel , Dict [ str , Any ]] inherited property writable \u00b6 The state machine execution context object. end_time: Optional [ datetime . datetime ] property readonly \u00b6 The datetime this state machine will end log: BoundLogger inherited property readonly \u00b6 Bound logger initialize with context information for this state machine. start_time: Optional [ datetime . datetime ] property readonly \u00b6 The datetime this state machine will start execution uuid: UUID inherited property readonly \u00b6 UUID for this state machine execution. For example used as unique run ID during when logging. __init__ ( self , initial_state , states , start_time = None , end_time = None , max_errors = 0 ) special \u00b6 Parameters: Name Type Description Default initial_state str The name of the initial state required states List[cr_kyoushi.simulation.states.State] List of all states the state machine can enter required start_time Optional[datetime.datetime] The datetime this state machine should start execution None end_time Optional[datetime.datetime] The datetime this state machine should end execution None max_errors int Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. 0 Note If state_time or end_time are None then the state machine will start or end execution normally. Source code in simulation/sm.py def __init__ ( self , initial_state : str , states : List [ State ], start_time : Optional [ datetime ] = None , end_time : Optional [ datetime ] = None , max_errors : int = 0 , ): \"\"\" Args: initial_state: The name of the initial state states: List of all states the state machine can enter start_time: The `datetime` this state machine should start execution end_time: The `datetime` this state machine should end execution max_errors: Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. !!! Note If `state_time` or `end_time` are `None` then the state machine will start or end execution normally. \"\"\" super () . __init__ ( initial_state , states , max_errors = max_errors ) self . __start_time = start_time self . __end_time = end_time destroy_context ( self ) inherited \u00b6 Destroy and clean up the state machine execution context Note Override or extend this function if your state machine needs run some logic or free Context information after it has finished executing. Source code in simulation/sm.py def destroy_context ( self ) -> None : \"\"\"Destroy and clean up the state machine execution context ??? Note Override or extend this function if your state machine needs run some logic or free `Context` information after it has finished executing. \"\"\" execute_machine ( self ) \u00b6 State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is None ) - or the current time is >= end_time Source code in simulation/sm.py def execute_machine ( self ): \"\"\"State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is `None`) - or the current time is >= `end_time` \"\"\" # state machine run main loop while self . current_state and not self . _is_end_time (): self . execute_step () execute_step ( self ) inherited \u00b6 Execute a single state machine step. This function delegates transition execution to execute_transition() . All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. Source code in simulation/sm.py def execute_step ( self ): \"\"\"Execute a single state machine step. This function delegates transition execution to `execute_transition()`. All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. ??? Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. \"\"\" assert self . current_state is not None # bind upcoming transition context to logger log : BoundLogger = self . log . bind ( current_state = self . current_state , transition = None , transition_id = uuid4 (), target = None , ) try : self . current_transition = self . states [ self . current_state ] . next ( log , self . context ) if self . current_transition : # bind selected transition and target to logger log = log . bind ( transition = self . current_transition . name , target = self . current_transition . target , ) # execute transition self . execute_transition ( log ) else : log . info ( \"Empty transition received state machine will end\" ) self . current_state = None except Exception : log . exception ( \"State machine execution failure\" ) # try to recover from error by restarting state machine self . errors += 1 if self . max_errors > self . errors : self . destroy_context () log . warning ( \"Trying to recover statemachine from exception \" ) self . setup_context () self . current_state = self . initial_state else : self . current_state = None execute_transition ( self , log ) inherited \u00b6 Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required Note Override or extend this if you want to change how transitions are executed or how [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. Source code in simulation/sm.py def execute_transition ( self , log : BoundLogger ): \"\"\"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Args: log: The bound logger initialized with transition specific information ??? Note Override or extend this if you want to change how transitions are executed or how [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. \"\"\" assert self . current_state is not None assert self . current_transition is not None try : log . info ( \"Executing transition %s -> %s \" , self . current_state , self . current_transition , ) self . current_state = self . current_transition . execute ( log , self . current_state , self . context ) log . info ( \"Moved to new state\" , new_state = self . current_state ) except errors . TransitionExecutionError as transition_error : log . warning ( \"Encountered a transition error: %s \" , transition_error ) if transition_error . fallback_state : log . warning ( \"Recovering to fallback state\" , fallback = transition_error . fallback_state , ) self . current_state = transition_error . fallback_state run ( self ) \u00b6 Starts the state machine execution. This will only start the state machine execution once the given start time is reached. Source code in simulation/sm.py def run ( self ): \"\"\"Starts the state machine execution. This will only start the state machine execution once the given start time is reached. \"\"\" # wait for start time before actually starting the machine if self . start_time is not None : sleep_until ( self . start_time ) return super () . run () setup_context ( self ) inherited \u00b6 Initialize and setup the state machine execution context Note Override this function if your state machine needs run some logic or set Context information before it can be executed. Source code in simulation/sm.py def setup_context ( self ) -> None : \"\"\"Initialize and setup the state machine execution context ??? Note Override this function if your state machine needs run some logic or set `Context` information before it can be executed. \"\"\" Statemachine \u00b6 Implements state control and transition logic This class implements basic state machine execution, i.e., execution starts at the configured initial state and continues until a end state (i.e., a state without outgoing transitions) is reached. A state machine can be started by calling the [ run() ][cr_kyoushi.simulation.sm.Statemachine.run] function. Note You can also execute a state machine step wise using execute_step() function manually. If you choose to do so be care full to remember to call setup_context() before you start execution and destroy_context() after the state machine is finished. Default state machine behavior can be extended or modified by creating a sub class and overriding the state machine functions [ execute_machine() ][cr_kyoushi.simulation.sm.Statemachine.execute_machine], [ execute_step() ][cr_kyoushi.simulation.sm.Statemachine.execute_step], [ execute_transition() ][cr_kyoushi.simulation.sm.Statemachine.execute_transition], etc. context: Union [ pydantic . main . BaseModel , Dict [ str , Any ]] property writable \u00b6 The state machine execution context object. log: BoundLogger property readonly \u00b6 Bound logger initialize with context information for this state machine. uuid: UUID property readonly \u00b6 UUID for this state machine execution. For example used as unique run ID during when logging. __init__ ( self , initial_state , states , max_errors = 0 ) special \u00b6 Parameters: Name Type Description Default initial_state str The name of the initial state required states List[cr_kyoushi.simulation.states.State] List of all states the state machine can enter required max_errors int Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. 0 Source code in simulation/sm.py def __init__ ( self , initial_state : str , states : List [ State ], max_errors : int = 0 , ): \"\"\" Args: initial_state: The name of the initial state states: List of all states the state machine can enter max_errors: Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. \"\"\" self . initial_state = initial_state self . current_state : Optional [ str ] = initial_state self . current_transition : Optional [ Transition ] = None self . states : Dict [ str , State ] = { state . name : state for state in states } self . context : Context = {} self . max_errors = max_errors self . errors = 0 self . __uuid = uuid4 () self . __log : BoundLogger = get_logger () . bind ( run = self . uuid ) self . log . info ( \"Created state machine\" , seed = get_seed ()) destroy_context ( self ) \u00b6 Destroy and clean up the state machine execution context Note Override or extend this function if your state machine needs run some logic or free Context information after it has finished executing. Source code in simulation/sm.py def destroy_context ( self ) -> None : \"\"\"Destroy and clean up the state machine execution context ??? Note Override or extend this function if your state machine needs run some logic or free `Context` information after it has finished executing. \"\"\" execute_machine ( self ) \u00b6 State machine main execution loop. This function executes state machine steps in a loop until a end state is reached (i.e., current state is None ). Note Override or extends this if you whish to change how your state machine does continues execution. Source code in simulation/sm.py def execute_machine ( self ): \"\"\"State machine main execution loop. This function executes state machine steps in a loop until a end state is reached (i.e., current state is `None`). ??? Note Override or extends this if you whish to change how your state machine does continues execution. \"\"\" # state machine run main loop while self . current_state : self . execute_step () execute_step ( self ) \u00b6 Execute a single state machine step. This function delegates transition execution to execute_transition() . All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. Source code in simulation/sm.py def execute_step ( self ): \"\"\"Execute a single state machine step. This function delegates transition execution to `execute_transition()`. All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. ??? Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. \"\"\" assert self . current_state is not None # bind upcoming transition context to logger log : BoundLogger = self . log . bind ( current_state = self . current_state , transition = None , transition_id = uuid4 (), target = None , ) try : self . current_transition = self . states [ self . current_state ] . next ( log , self . context ) if self . current_transition : # bind selected transition and target to logger log = log . bind ( transition = self . current_transition . name , target = self . current_transition . target , ) # execute transition self . execute_transition ( log ) else : log . info ( \"Empty transition received state machine will end\" ) self . current_state = None except Exception : log . exception ( \"State machine execution failure\" ) # try to recover from error by restarting state machine self . errors += 1 if self . max_errors > self . errors : self . destroy_context () log . warning ( \"Trying to recover statemachine from exception \" ) self . setup_context () self . current_state = self . initial_state else : self . current_state = None execute_transition ( self , log ) \u00b6 Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required Note Override or extend this if you want to change how transitions are executed or how [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. Source code in simulation/sm.py def execute_transition ( self , log : BoundLogger ): \"\"\"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Args: log: The bound logger initialized with transition specific information ??? Note Override or extend this if you want to change how transitions are executed or how [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. \"\"\" assert self . current_state is not None assert self . current_transition is not None try : log . info ( \"Executing transition %s -> %s \" , self . current_state , self . current_transition , ) self . current_state = self . current_transition . execute ( log , self . current_state , self . context ) log . info ( \"Moved to new state\" , new_state = self . current_state ) except errors . TransitionExecutionError as transition_error : log . warning ( \"Encountered a transition error: %s \" , transition_error ) if transition_error . fallback_state : log . warning ( \"Recovering to fallback state\" , fallback = transition_error . fallback_state , ) self . current_state = transition_error . fallback_state run ( self ) \u00b6 Starts the state machine execution. The state machine execution context is setup before executing the state machine main loop and destroyed again after the main loop ends. Source code in simulation/sm.py def run ( self ) -> None : \"\"\"Starts the state machine execution. The state machine execution context is setup before executing the state machine main loop and destroyed again after the main loop ends. \"\"\" # prepare state machine before start self . log . info ( \"Starting state machine\" ) self . setup_context () # execute the state machine self . log . info ( \"Entering state machine execution\" ) self . execute_machine () # clean up state machine self . destroy_context () self . log . info ( \"State machine finished\" ) setup_context ( self ) \u00b6 Initialize and setup the state machine execution context Note Override this function if your state machine needs run some logic or set Context information before it can be executed. Source code in simulation/sm.py def setup_context ( self ) -> None : \"\"\"Initialize and setup the state machine execution context ??? Note Override this function if your state machine needs run some logic or set `Context` information before it can be executed. \"\"\" StatemachineFactory \u00b6 Abstract class definition for factories generating state machines State machine factories are used by the CLI system to load dynamically load state machines from entrypoints or python files. A state machine factory must have a name and a config class . config_class: Type [ ~ StatemachineConfig ] property readonly \u00b6 The config class to use for the state machine. You can use the configuration class to define all required and optional configuration options for your state machine. e.g., to make it possible for users of your state machine to configure the probabilities for [ ProbabilisticStates ][cr_kyoushi.simulation.states.ProbabilisticState]. The CLI system dynamically loads and validates configuration for your state machine based on the config class. Pydantic is used for this so it is recommended to define your config class must be a pydantic model or any other field type pydantic can handle. name: str property readonly \u00b6 The name of the state machine factory. build ( self , config ) \u00b6 Builds the state machine instance. The build function must also create and initialize all states and transitions required by the state machine. This is called by the CLI system to create the state machine before executing it. Parameters: Name Type Description Default config ~StatemachineConfig Configuration for your state machine. required Returns: Type Description Statemachine Statemachine: Statemachine instances created based on the given configuration. Source code in simulation/sm.py @abstractmethod def build ( self , config : StatemachineConfig ) -> Statemachine : \"\"\"Builds the state machine instance. The build function must also create and initialize all states and transitions required by the state machine. This is called by the CLI system to create the state machine before executing it. Args: config: Configuration for your state machine. Returns: Statemachine: Statemachine instances created based on the given configuration. \"\"\" WorkHoursStatemachine \u00b6 State machine optionally allows the configuration of work hours. Note This state machine extends [ StartEndTimeStatemachine ][cr_kyoushi.simulation.sm.StartEndTimeStatemachine] and as such has all its features. Work hours are defined through the configuration of a [ ActivePeriod ][cr_kyoushi.simulation.model.ActivePeriod]. Outside of its work hours this state machine will simply idle and do nothing. You can also configure context: Union [ pydantic . main . BaseModel , Dict [ str , Any ]] inherited property writable \u00b6 The state machine execution context object. end_time: Optional [ datetime . datetime ] inherited property readonly \u00b6 The datetime this state machine will end log: BoundLogger inherited property readonly \u00b6 Bound logger initialize with context information for this state machine. start_time: Optional [ datetime . datetime ] inherited property readonly \u00b6 The datetime this state machine will start execution uuid: UUID inherited property readonly \u00b6 UUID for this state machine execution. For example used as unique run ID during when logging. work_schedule: Optional [ cr_kyoushi . simulation . model . WorkSchedule ] property readonly \u00b6 The work schedules for this state machine __init__ ( self , initial_state , states , start_time = None , end_time = None , work_schedule = None , max_errors = 0 ) special \u00b6 Parameters: Name Type Description Default initial_state str The name of the initial state required states List[cr_kyoushi.simulation.states.State] List of all states the state machine can enter required start_time Optional[datetime.datetime] The datetime this state machine should start execution None end_time Optional[datetime.datetime] The datetime this state machine should end execution None work_schedule Optional[cr_kyoushi.simulation.model.WorkSchedule] The state machines work schedule (days and times to work) None max_errors int Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. 0 Note If state_time or end_time are None then the state machine will start or end execution normally. Source code in simulation/sm.py def __init__ ( self , initial_state : str , states : List [ State ], start_time : Optional [ datetime ] = None , end_time : Optional [ datetime ] = None , work_schedule : Optional [ WorkSchedule ] = None , max_errors : int = 0 , ): \"\"\" Args: initial_state: The name of the initial state states: List of all states the state machine can enter start_time: The `datetime` this state machine should start execution end_time: The `datetime` this state machine should end execution work_schedule: The state machines work schedule (days and times to work) max_errors: Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. !!! Note If `state_time` or `end_time` are `None` then the state machine will start or end execution normally. \"\"\" super () . __init__ ( initial_state , states , start_time = start_time , end_time = end_time , max_errors = max_errors , ) self . __work_schedule = work_schedule _pause_work ( self ) private \u00b6 The pause work metho will be called before pausing the SM until the next work time. Use this method to destroy any resources that should not be active outside the work hours (e.g., the selenium browser). Also see _resume_work Hint You could simply destroy your context and set the SM to the initial state: self . current_state = self . initial_state # reset context self . destroy_context () Source code in simulation/sm.py def _pause_work ( self ): \"\"\"The pause work metho will be called before pausing the SM until the next work time. Use this method to destroy any resources that should not be active outside the work hours (e.g., the selenium browser). Also see `_resume_work` !!! Hint You could simply destroy your context and set the SM to the initial state: ```python self.current_state = self.initial_state # reset context self.destroy_context() ``` \"\"\" _resume_work ( self ) private \u00b6 The resume work method will be called before resuming work after sleeping. Use this method to prepare the state machine to resume after a potentially long pause. By default this method does nothing. Also see _pause_work . Hint You could for example configure your state machine to recreate from the initial state before resuming work: self . setup_context () Source code in simulation/sm.py def _resume_work ( self ): \"\"\"The resume work method will be called before resuming work after sleeping. Use this method to prepare the state machine to resume after a potentially long pause. By default this method does nothing. Also see `_pause_work`. !!! Hint You could for example configure your state machine to recreate from the initial state before resuming work: ```python self.setup_context() ``` \"\"\" _wait_for_work ( self ) private \u00b6 Idle until it is time to work again. Before returning to the normal state machine flow this will also call [ _resume_work ][cr_kyoushi.simulation.sm.WorkHoursStatemachine._resume_work]. Note If the next potential work time is after the machines end time it will not sleep, but instead set the current state to None and let the state machine flow end execution. Source code in simulation/sm.py def _wait_for_work ( self ): \"\"\"Idle until it is time to work again. Before returning to the normal state machine flow this will also call [`_resume_work`][cr_kyoushi.simulation.sm.WorkHoursStatemachine._resume_work]. !!! Note If the next potential work time is after the machines end time it will not sleep, but instead set the current state to `None` and let the state machine flow end execution. \"\"\" # immediately return if there is no work schedule if self . work_schedule is None : return next_work = self . work_schedule . next_work_start ( now ()) # if there is no next work time or the machine will end # before the next work we stop immediately if next_work is None or ( self . end_time is not None and self . end_time <= next_work ): self . current_state = None else : self . log . info ( \"Pausing state machine\" ) self . _pause_work () self . log . info ( \"Paused state machine\" ) # wait til we have work again sleep_until ( next_work ) # and then pre-pare to resume work self . log . info ( \"Resuming state machine\" ) self . _resume_work () self . log . info ( \"Resumed state machine\" ) destroy_context ( self ) inherited \u00b6 Destroy and clean up the state machine execution context Note Override or extend this function if your state machine needs run some logic or free Context information after it has finished executing. Source code in simulation/sm.py def destroy_context ( self ) -> None : \"\"\"Destroy and clean up the state machine execution context ??? Note Override or extend this function if your state machine needs run some logic or free `Context` information after it has finished executing. \"\"\" execute_machine ( self ) inherited \u00b6 State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is None ) - or the current time is >= end_time Source code in simulation/sm.py def execute_machine ( self ): \"\"\"State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is `None`) - or the current time is >= `end_time` \"\"\" # state machine run main loop while self . current_state and not self . _is_end_time (): self . execute_step () execute_step ( self ) \u00b6 Execute a single state machine step. This will only execute a step if the current time is within our work schedule. Outside the work time the state machine will [wait until work][cr_kyoushi.simulation.sm.WorkHoursStatemachine._wait_for_work] begins again. Source code in simulation/sm.py def execute_step ( self ): \"\"\"Execute a single state machine step. This will only execute a step if the current time is within our work schedule. Outside the work time the state machine will [wait until work][cr_kyoushi.simulation.sm.WorkHoursStatemachine._wait_for_work] begins again. \"\"\" # when we are in work hours business as usual if self . _in_work_hours (): super () . execute_step () # outside of work hours we idle else : self . _wait_for_work () execute_transition ( self , log ) inherited \u00b6 Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required Note Override or extend this if you want to change how transitions are executed or how [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. Source code in simulation/sm.py def execute_transition ( self , log : BoundLogger ): \"\"\"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Args: log: The bound logger initialized with transition specific information ??? Note Override or extend this if you want to change how transitions are executed or how [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. \"\"\" assert self . current_state is not None assert self . current_transition is not None try : log . info ( \"Executing transition %s -> %s \" , self . current_state , self . current_transition , ) self . current_state = self . current_transition . execute ( log , self . current_state , self . context ) log . info ( \"Moved to new state\" , new_state = self . current_state ) except errors . TransitionExecutionError as transition_error : log . warning ( \"Encountered a transition error: %s \" , transition_error ) if transition_error . fallback_state : log . warning ( \"Recovering to fallback state\" , fallback = transition_error . fallback_state , ) self . current_state = transition_error . fallback_state run ( self ) inherited \u00b6 Starts the state machine execution. This will only start the state machine execution once the given start time is reached. Source code in simulation/sm.py def run ( self ): \"\"\"Starts the state machine execution. This will only start the state machine execution once the given start time is reached. \"\"\" # wait for start time before actually starting the machine if self . start_time is not None : sleep_until ( self . start_time ) return super () . run () setup_context ( self ) inherited \u00b6 Initialize and setup the state machine execution context Note Override this function if your state machine needs run some logic or set Context information before it can be executed. Source code in simulation/sm.py def setup_context ( self ) -> None : \"\"\"Initialize and setup the state machine execution context ??? Note Override this function if your state machine needs run some logic or set `Context` information before it can be executed. \"\"\"","title":"State Machine"},{"location":"reference/sm/#statemachine-module","text":"","title":"Statemachine module"},{"location":"reference/sm/#cr_kyoushi.simulation.sm","text":"State machine module This module contains all class and function defintions for creating and defining Cyber Range Kyoushi simulation machines.","title":"cr_kyoushi.simulation.sm"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine","text":"Special type of state machine that allows configuring a start and end time. The main stat machine execution loop will only start execution once it is the configured start time (starts immediately if none is configured). Similarly the state machine will stop once the current time is the end time even if there are still transitions left to execute. This is for example useful when you wish to configure a state machine to only run for the duration of an experiment. Note A state machine might end before its end time if it enters a final state.","title":"StartEndTimeStatemachine"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.context","text":"The state machine execution context object.","title":"context"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.end_time","text":"The datetime this state machine will end","title":"end_time"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.log","text":"Bound logger initialize with context information for this state machine.","title":"log"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.start_time","text":"The datetime this state machine will start execution","title":"start_time"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.uuid","text":"UUID for this state machine execution. For example used as unique run ID during when logging.","title":"uuid"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.__init__","text":"Parameters: Name Type Description Default initial_state str The name of the initial state required states List[cr_kyoushi.simulation.states.State] List of all states the state machine can enter required start_time Optional[datetime.datetime] The datetime this state machine should start execution None end_time Optional[datetime.datetime] The datetime this state machine should end execution None max_errors int Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. 0 Note If state_time or end_time are None then the state machine will start or end execution normally. Source code in simulation/sm.py def __init__ ( self , initial_state : str , states : List [ State ], start_time : Optional [ datetime ] = None , end_time : Optional [ datetime ] = None , max_errors : int = 0 , ): \"\"\" Args: initial_state: The name of the initial state states: List of all states the state machine can enter start_time: The `datetime` this state machine should start execution end_time: The `datetime` this state machine should end execution max_errors: Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. !!! Note If `state_time` or `end_time` are `None` then the state machine will start or end execution normally. \"\"\" super () . __init__ ( initial_state , states , max_errors = max_errors ) self . __start_time = start_time self . __end_time = end_time","title":"__init__()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.destroy_context","text":"Destroy and clean up the state machine execution context Note Override or extend this function if your state machine needs run some logic or free Context information after it has finished executing. Source code in simulation/sm.py def destroy_context ( self ) -> None : \"\"\"Destroy and clean up the state machine execution context ??? Note Override or extend this function if your state machine needs run some logic or free `Context` information after it has finished executing. \"\"\"","title":"destroy_context()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.execute_machine","text":"State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is None ) - or the current time is >= end_time Source code in simulation/sm.py def execute_machine ( self ): \"\"\"State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is `None`) - or the current time is >= `end_time` \"\"\" # state machine run main loop while self . current_state and not self . _is_end_time (): self . execute_step ()","title":"execute_machine()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.execute_step","text":"Execute a single state machine step. This function delegates transition execution to execute_transition() . All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. Source code in simulation/sm.py def execute_step ( self ): \"\"\"Execute a single state machine step. This function delegates transition execution to `execute_transition()`. All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. ??? Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. \"\"\" assert self . current_state is not None # bind upcoming transition context to logger log : BoundLogger = self . log . bind ( current_state = self . current_state , transition = None , transition_id = uuid4 (), target = None , ) try : self . current_transition = self . states [ self . current_state ] . next ( log , self . context ) if self . current_transition : # bind selected transition and target to logger log = log . bind ( transition = self . current_transition . name , target = self . current_transition . target , ) # execute transition self . execute_transition ( log ) else : log . info ( \"Empty transition received state machine will end\" ) self . current_state = None except Exception : log . exception ( \"State machine execution failure\" ) # try to recover from error by restarting state machine self . errors += 1 if self . max_errors > self . errors : self . destroy_context () log . warning ( \"Trying to recover statemachine from exception \" ) self . setup_context () self . current_state = self . initial_state else : self . current_state = None","title":"execute_step()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.execute_transition","text":"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required Note Override or extend this if you want to change how transitions are executed or how [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. Source code in simulation/sm.py def execute_transition ( self , log : BoundLogger ): \"\"\"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Args: log: The bound logger initialized with transition specific information ??? Note Override or extend this if you want to change how transitions are executed or how [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. \"\"\" assert self . current_state is not None assert self . current_transition is not None try : log . info ( \"Executing transition %s -> %s \" , self . current_state , self . current_transition , ) self . current_state = self . current_transition . execute ( log , self . current_state , self . context ) log . info ( \"Moved to new state\" , new_state = self . current_state ) except errors . TransitionExecutionError as transition_error : log . warning ( \"Encountered a transition error: %s \" , transition_error ) if transition_error . fallback_state : log . warning ( \"Recovering to fallback state\" , fallback = transition_error . fallback_state , ) self . current_state = transition_error . fallback_state","title":"execute_transition()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.run","text":"Starts the state machine execution. This will only start the state machine execution once the given start time is reached. Source code in simulation/sm.py def run ( self ): \"\"\"Starts the state machine execution. This will only start the state machine execution once the given start time is reached. \"\"\" # wait for start time before actually starting the machine if self . start_time is not None : sleep_until ( self . start_time ) return super () . run ()","title":"run()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StartEndTimeStatemachine.setup_context","text":"Initialize and setup the state machine execution context Note Override this function if your state machine needs run some logic or set Context information before it can be executed. Source code in simulation/sm.py def setup_context ( self ) -> None : \"\"\"Initialize and setup the state machine execution context ??? Note Override this function if your state machine needs run some logic or set `Context` information before it can be executed. \"\"\"","title":"setup_context()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine","text":"Implements state control and transition logic This class implements basic state machine execution, i.e., execution starts at the configured initial state and continues until a end state (i.e., a state without outgoing transitions) is reached. A state machine can be started by calling the [ run() ][cr_kyoushi.simulation.sm.Statemachine.run] function. Note You can also execute a state machine step wise using execute_step() function manually. If you choose to do so be care full to remember to call setup_context() before you start execution and destroy_context() after the state machine is finished. Default state machine behavior can be extended or modified by creating a sub class and overriding the state machine functions [ execute_machine() ][cr_kyoushi.simulation.sm.Statemachine.execute_machine], [ execute_step() ][cr_kyoushi.simulation.sm.Statemachine.execute_step], [ execute_transition() ][cr_kyoushi.simulation.sm.Statemachine.execute_transition], etc.","title":"Statemachine"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.context","text":"The state machine execution context object.","title":"context"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.log","text":"Bound logger initialize with context information for this state machine.","title":"log"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.uuid","text":"UUID for this state machine execution. For example used as unique run ID during when logging.","title":"uuid"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.__init__","text":"Parameters: Name Type Description Default initial_state str The name of the initial state required states List[cr_kyoushi.simulation.states.State] List of all states the state machine can enter required max_errors int Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. 0 Source code in simulation/sm.py def __init__ ( self , initial_state : str , states : List [ State ], max_errors : int = 0 , ): \"\"\" Args: initial_state: The name of the initial state states: List of all states the state machine can enter max_errors: Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. \"\"\" self . initial_state = initial_state self . current_state : Optional [ str ] = initial_state self . current_transition : Optional [ Transition ] = None self . states : Dict [ str , State ] = { state . name : state for state in states } self . context : Context = {} self . max_errors = max_errors self . errors = 0 self . __uuid = uuid4 () self . __log : BoundLogger = get_logger () . bind ( run = self . uuid ) self . log . info ( \"Created state machine\" , seed = get_seed ())","title":"__init__()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.destroy_context","text":"Destroy and clean up the state machine execution context Note Override or extend this function if your state machine needs run some logic or free Context information after it has finished executing. Source code in simulation/sm.py def destroy_context ( self ) -> None : \"\"\"Destroy and clean up the state machine execution context ??? Note Override or extend this function if your state machine needs run some logic or free `Context` information after it has finished executing. \"\"\"","title":"destroy_context()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.execute_machine","text":"State machine main execution loop. This function executes state machine steps in a loop until a end state is reached (i.e., current state is None ). Note Override or extends this if you whish to change how your state machine does continues execution. Source code in simulation/sm.py def execute_machine ( self ): \"\"\"State machine main execution loop. This function executes state machine steps in a loop until a end state is reached (i.e., current state is `None`). ??? Note Override or extends this if you whish to change how your state machine does continues execution. \"\"\" # state machine run main loop while self . current_state : self . execute_step ()","title":"execute_machine()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.execute_step","text":"Execute a single state machine step. This function delegates transition execution to execute_transition() . All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. Source code in simulation/sm.py def execute_step ( self ): \"\"\"Execute a single state machine step. This function delegates transition execution to `execute_transition()`. All pre and post execution tasks such as retrieving the transition from the current state before the transition and handeling unexpected errors encountered during transition execution. ??? Note Override or extend this function if you whish to change pre-, post-execution and handling of all unexpected errors. \"\"\" assert self . current_state is not None # bind upcoming transition context to logger log : BoundLogger = self . log . bind ( current_state = self . current_state , transition = None , transition_id = uuid4 (), target = None , ) try : self . current_transition = self . states [ self . current_state ] . next ( log , self . context ) if self . current_transition : # bind selected transition and target to logger log = log . bind ( transition = self . current_transition . name , target = self . current_transition . target , ) # execute transition self . execute_transition ( log ) else : log . info ( \"Empty transition received state machine will end\" ) self . current_state = None except Exception : log . exception ( \"State machine execution failure\" ) # try to recover from error by restarting state machine self . errors += 1 if self . max_errors > self . errors : self . destroy_context () log . warning ( \"Trying to recover statemachine from exception \" ) self . setup_context () self . current_state = self . initial_state else : self . current_state = None","title":"execute_step()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.execute_transition","text":"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required Note Override or extend this if you want to change how transitions are executed or how [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. Source code in simulation/sm.py def execute_transition ( self , log : BoundLogger ): \"\"\"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Args: log: The bound logger initialized with transition specific information ??? Note Override or extend this if you want to change how transitions are executed or how [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. \"\"\" assert self . current_state is not None assert self . current_transition is not None try : log . info ( \"Executing transition %s -> %s \" , self . current_state , self . current_transition , ) self . current_state = self . current_transition . execute ( log , self . current_state , self . context ) log . info ( \"Moved to new state\" , new_state = self . current_state ) except errors . TransitionExecutionError as transition_error : log . warning ( \"Encountered a transition error: %s \" , transition_error ) if transition_error . fallback_state : log . warning ( \"Recovering to fallback state\" , fallback = transition_error . fallback_state , ) self . current_state = transition_error . fallback_state","title":"execute_transition()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.run","text":"Starts the state machine execution. The state machine execution context is setup before executing the state machine main loop and destroyed again after the main loop ends. Source code in simulation/sm.py def run ( self ) -> None : \"\"\"Starts the state machine execution. The state machine execution context is setup before executing the state machine main loop and destroyed again after the main loop ends. \"\"\" # prepare state machine before start self . log . info ( \"Starting state machine\" ) self . setup_context () # execute the state machine self . log . info ( \"Entering state machine execution\" ) self . execute_machine () # clean up state machine self . destroy_context () self . log . info ( \"State machine finished\" )","title":"run()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.Statemachine.setup_context","text":"Initialize and setup the state machine execution context Note Override this function if your state machine needs run some logic or set Context information before it can be executed. Source code in simulation/sm.py def setup_context ( self ) -> None : \"\"\"Initialize and setup the state machine execution context ??? Note Override this function if your state machine needs run some logic or set `Context` information before it can be executed. \"\"\"","title":"setup_context()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StatemachineFactory","text":"Abstract class definition for factories generating state machines State machine factories are used by the CLI system to load dynamically load state machines from entrypoints or python files. A state machine factory must have a name and a config class .","title":"StatemachineFactory"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StatemachineFactory.config_class","text":"The config class to use for the state machine. You can use the configuration class to define all required and optional configuration options for your state machine. e.g., to make it possible for users of your state machine to configure the probabilities for [ ProbabilisticStates ][cr_kyoushi.simulation.states.ProbabilisticState]. The CLI system dynamically loads and validates configuration for your state machine based on the config class. Pydantic is used for this so it is recommended to define your config class must be a pydantic model or any other field type pydantic can handle.","title":"config_class"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StatemachineFactory.name","text":"The name of the state machine factory.","title":"name"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.StatemachineFactory.build","text":"Builds the state machine instance. The build function must also create and initialize all states and transitions required by the state machine. This is called by the CLI system to create the state machine before executing it. Parameters: Name Type Description Default config ~StatemachineConfig Configuration for your state machine. required Returns: Type Description Statemachine Statemachine: Statemachine instances created based on the given configuration. Source code in simulation/sm.py @abstractmethod def build ( self , config : StatemachineConfig ) -> Statemachine : \"\"\"Builds the state machine instance. The build function must also create and initialize all states and transitions required by the state machine. This is called by the CLI system to create the state machine before executing it. Args: config: Configuration for your state machine. Returns: Statemachine: Statemachine instances created based on the given configuration. \"\"\"","title":"build()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine","text":"State machine optionally allows the configuration of work hours. Note This state machine extends [ StartEndTimeStatemachine ][cr_kyoushi.simulation.sm.StartEndTimeStatemachine] and as such has all its features. Work hours are defined through the configuration of a [ ActivePeriod ][cr_kyoushi.simulation.model.ActivePeriod]. Outside of its work hours this state machine will simply idle and do nothing. You can also configure","title":"WorkHoursStatemachine"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.context","text":"The state machine execution context object.","title":"context"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.end_time","text":"The datetime this state machine will end","title":"end_time"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.log","text":"Bound logger initialize with context information for this state machine.","title":"log"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.start_time","text":"The datetime this state machine will start execution","title":"start_time"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.uuid","text":"UUID for this state machine execution. For example used as unique run ID during when logging.","title":"uuid"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.work_schedule","text":"The work schedules for this state machine","title":"work_schedule"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.__init__","text":"Parameters: Name Type Description Default initial_state str The name of the initial state required states List[cr_kyoushi.simulation.states.State] List of all states the state machine can enter required start_time Optional[datetime.datetime] The datetime this state machine should start execution None end_time Optional[datetime.datetime] The datetime this state machine should end execution None work_schedule Optional[cr_kyoushi.simulation.model.WorkSchedule] The state machines work schedule (days and times to work) None max_errors int Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. 0 Note If state_time or end_time are None then the state machine will start or end execution normally. Source code in simulation/sm.py def __init__ ( self , initial_state : str , states : List [ State ], start_time : Optional [ datetime ] = None , end_time : Optional [ datetime ] = None , work_schedule : Optional [ WorkSchedule ] = None , max_errors : int = 0 , ): \"\"\" Args: initial_state: The name of the initial state states: List of all states the state machine can enter start_time: The `datetime` this state machine should start execution end_time: The `datetime` this state machine should end execution work_schedule: The state machines work schedule (days and times to work) max_errors: Maximum amount of errors the state machine is allowed to encounter before it stops trying to recover by reseting to the initial state. !!! Note If `state_time` or `end_time` are `None` then the state machine will start or end execution normally. \"\"\" super () . __init__ ( initial_state , states , start_time = start_time , end_time = end_time , max_errors = max_errors , ) self . __work_schedule = work_schedule","title":"__init__()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine._pause_work","text":"The pause work metho will be called before pausing the SM until the next work time. Use this method to destroy any resources that should not be active outside the work hours (e.g., the selenium browser). Also see _resume_work Hint You could simply destroy your context and set the SM to the initial state: self . current_state = self . initial_state # reset context self . destroy_context () Source code in simulation/sm.py def _pause_work ( self ): \"\"\"The pause work metho will be called before pausing the SM until the next work time. Use this method to destroy any resources that should not be active outside the work hours (e.g., the selenium browser). Also see `_resume_work` !!! Hint You could simply destroy your context and set the SM to the initial state: ```python self.current_state = self.initial_state # reset context self.destroy_context() ``` \"\"\"","title":"_pause_work()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine._resume_work","text":"The resume work method will be called before resuming work after sleeping. Use this method to prepare the state machine to resume after a potentially long pause. By default this method does nothing. Also see _pause_work . Hint You could for example configure your state machine to recreate from the initial state before resuming work: self . setup_context () Source code in simulation/sm.py def _resume_work ( self ): \"\"\"The resume work method will be called before resuming work after sleeping. Use this method to prepare the state machine to resume after a potentially long pause. By default this method does nothing. Also see `_pause_work`. !!! Hint You could for example configure your state machine to recreate from the initial state before resuming work: ```python self.setup_context() ``` \"\"\"","title":"_resume_work()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine._wait_for_work","text":"Idle until it is time to work again. Before returning to the normal state machine flow this will also call [ _resume_work ][cr_kyoushi.simulation.sm.WorkHoursStatemachine._resume_work]. Note If the next potential work time is after the machines end time it will not sleep, but instead set the current state to None and let the state machine flow end execution. Source code in simulation/sm.py def _wait_for_work ( self ): \"\"\"Idle until it is time to work again. Before returning to the normal state machine flow this will also call [`_resume_work`][cr_kyoushi.simulation.sm.WorkHoursStatemachine._resume_work]. !!! Note If the next potential work time is after the machines end time it will not sleep, but instead set the current state to `None` and let the state machine flow end execution. \"\"\" # immediately return if there is no work schedule if self . work_schedule is None : return next_work = self . work_schedule . next_work_start ( now ()) # if there is no next work time or the machine will end # before the next work we stop immediately if next_work is None or ( self . end_time is not None and self . end_time <= next_work ): self . current_state = None else : self . log . info ( \"Pausing state machine\" ) self . _pause_work () self . log . info ( \"Paused state machine\" ) # wait til we have work again sleep_until ( next_work ) # and then pre-pare to resume work self . log . info ( \"Resuming state machine\" ) self . _resume_work () self . log . info ( \"Resumed state machine\" )","title":"_wait_for_work()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.destroy_context","text":"Destroy and clean up the state machine execution context Note Override or extend this function if your state machine needs run some logic or free Context information after it has finished executing. Source code in simulation/sm.py def destroy_context ( self ) -> None : \"\"\"Destroy and clean up the state machine execution context ??? Note Override or extend this function if your state machine needs run some logic or free `Context` information after it has finished executing. \"\"\"","title":"destroy_context()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.execute_machine","text":"State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is None ) - or the current time is >= end_time Source code in simulation/sm.py def execute_machine ( self ): \"\"\"State machine main execution loop. This function executes state machine steps in a loop until either - a end state is reached (i.e., current state is `None`) - or the current time is >= `end_time` \"\"\" # state machine run main loop while self . current_state and not self . _is_end_time (): self . execute_step ()","title":"execute_machine()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.execute_step","text":"Execute a single state machine step. This will only execute a step if the current time is within our work schedule. Outside the work time the state machine will [wait until work][cr_kyoushi.simulation.sm.WorkHoursStatemachine._wait_for_work] begins again. Source code in simulation/sm.py def execute_step ( self ): \"\"\"Execute a single state machine step. This will only execute a step if the current time is within our work schedule. Outside the work time the state machine will [wait until work][cr_kyoushi.simulation.sm.WorkHoursStatemachine._wait_for_work] begins again. \"\"\" # when we are in work hours business as usual if self . _in_work_hours (): super () . execute_step () # outside of work hours we idle else : self . _wait_for_work ()","title":"execute_step()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.execute_transition","text":"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required Note Override or extend this if you want to change how transitions are executed or how [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. Source code in simulation/sm.py def execute_transition ( self , log : BoundLogger ): \"\"\"Execute the current transition. The current transition is executed and the current state is updated on successful executions. This function also handles [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] and sets the state machines current state to the errors fallback state. Args: log: The bound logger initialized with transition specific information ??? Note Override or extend this if you want to change how transitions are executed or how [`TransitionExecutionErrors`][cr_kyoushi.simulation.errors.TransitionExecutionError] are handled. \"\"\" assert self . current_state is not None assert self . current_transition is not None try : log . info ( \"Executing transition %s -> %s \" , self . current_state , self . current_transition , ) self . current_state = self . current_transition . execute ( log , self . current_state , self . context ) log . info ( \"Moved to new state\" , new_state = self . current_state ) except errors . TransitionExecutionError as transition_error : log . warning ( \"Encountered a transition error: %s \" , transition_error ) if transition_error . fallback_state : log . warning ( \"Recovering to fallback state\" , fallback = transition_error . fallback_state , ) self . current_state = transition_error . fallback_state","title":"execute_transition()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.run","text":"Starts the state machine execution. This will only start the state machine execution once the given start time is reached. Source code in simulation/sm.py def run ( self ): \"\"\"Starts the state machine execution. This will only start the state machine execution once the given start time is reached. \"\"\" # wait for start time before actually starting the machine if self . start_time is not None : sleep_until ( self . start_time ) return super () . run ()","title":"run()"},{"location":"reference/sm/#cr_kyoushi.simulation.sm.WorkHoursStatemachine.setup_context","text":"Initialize and setup the state machine execution context Note Override this function if your state machine needs run some logic or set Context information before it can be executed. Source code in simulation/sm.py def setup_context ( self ) -> None : \"\"\"Initialize and setup the state machine execution context ??? Note Override this function if your state machine needs run some logic or set `Context` information before it can be executed. \"\"\"","title":"setup_context()"},{"location":"reference/states/","text":"States module \u00b6 \u00b6 AdaptiveProbabilisticState \u00b6 Special probabilistic state that allows modifaction of weights. modifiers: List [ float ] property readonly \u00b6 The weight modifiers assigned to the transitions. name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. probabilities: List [ float ] property readonly \u00b6 The propabilities based on the weights and modifiers transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state weights: Sequence [ float ] inherited property readonly \u00b6 The weight assigned to the transitions. __init__ ( self , name , transitions , weights , modifiers = None , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The name of the state required transitions List[cr_kyoushi.simulation.transitions.Transition] The list of transitions required weights Sequence[float] The list of weights to assign to the transitions in propability notation required modifiers Optional[Sequence[float]] List of multiplicative modifiers for each weight. Will default to all 1 if not set. None name_prefix Optional[str] A prefix for the state name None Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], weights : Sequence [ float ], modifiers : Optional [ Sequence [ float ]] = None , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The name of the state transitions: The list of transitions weights: The list of weights to assign to the transitions in propability notation modifiers: List of multiplicative modifiers for each weight. Will default to all 1 if not set. name_prefix: A prefix for the state name \"\"\" super () . __init__ ( name , transitions , weights , name_prefix ) if modifiers is None : modifiers = [ 1.0 ] * len ( self . weights ) self . _modifiers = dict ( zip ( transitions , list ( modifiers ))) self . __modifiers_org : Tuple [ float , ... ] = tuple ( self . modifiers ) adapt_after ( self , log , context , selected ) \u00b6 Hook to update the weight modifiers after the transition selection. Parameters: Name Type Description Default log BoundLogger The logger for the sm context required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required selected Optional[cr_kyoushi.simulation.transitions.Transition] The transition selected in this next call required Source code in simulation/states.py def adapt_after ( self , log : BoundLogger , context : Context , selected : Optional [ Transition ], ): \"\"\"Hook to update the weight modifiers after the transition selection. Args: log: The logger for the sm context context: The state machine context selected: The transition selected in this next call \"\"\" adapt_before ( self , log , context ) \u00b6 Hook to update the weight modifiers before the transition selection. Parameters: Name Type Description Default log BoundLogger The logger for the sm context required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Source code in simulation/states.py def adapt_before ( self , log : BoundLogger , context : Context ): \"\"\"Hook to update the weight modifiers before the transition selection. Args: log: The logger for the sm context context: The state machine context \"\"\" next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: if len ( self . transitions ) > 0 : self . adapt_before ( log , context ) selected = np . random . choice ( a = np . array ( self . transitions ), p = self . probabilities ) self . adapt_after ( log , context , selected ) return selected return None reset ( self ) \u00b6 Resets the modifiers to their original state Source code in simulation/states.py def reset ( self ): \"\"\"Resets the modifiers to their original state\"\"\" self . _modifiers = dict ( zip ( self . transitions , self . __modifiers_org )) ChoiceState \u00b6 Simple boolean choice state decides between two transitions name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. no: Transition property readonly \u00b6 The transition that is returned when the decision function returns False transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state yes: Transition property readonly \u00b6 The transition that is returned when the decision function returns True __init__ ( self , name , decision_function , yes , no , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required decision_function Callable[[structlog.stdlib.BoundLogger, Union[pydantic.main.BaseModel, Dict[str, Any]]], bool] Context function that decides a yes/no question. required yes Transition The transition to return when the decision function returns True required no Transition The transition to return when the decision function returns False required name_prefix Optional[str] A prefix for the state name None Source code in simulation/states.py def __init__ ( self , name : str , decision_function : Callable [[ BoundLogger , Context ], bool ], yes : Transition , no : Transition , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name decision_function: Context function that decides a yes/no question. yes: The transition to return when the decision function returns `True` no: The transition to return when the decision function returns `False` name_prefix: A prefix for the state name \"\"\" super () . __init__ ( name , [ yes , no ], name_prefix ) self . __decision_function : Callable [ [ BoundLogger , Context ], bool ] = decision_function next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: return self . yes if self . __decision_function ( log , context ) else self . no EquallyRandomState \u00b6 Special type of probabilistic state using an equal random distribution for all transitions name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state weights: Sequence [ float ] inherited property readonly \u00b6 The weight assigned to the transitions. __init__ ( self , name , transitions , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] The list of transitions required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transitions: The list of transitions name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names \"\"\" # create even random distribution probability = 1.0 / len ( transitions ) weights = [ probability for i in range ( 0 , len ( transitions ))] # initialize using super super () . __init__ ( name , transitions , weights , name_prefix ) next ( self , log , context ) inherited \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: if len ( self . transitions ) > 0 : return np . random . choice ( a = np . array ( self . transitions ), p = self . weights ) return None FinalState \u00b6 State with not further transitions which can be used as final state of a state machine name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state __init__ ( self , name , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required name_prefix Optional[str] A prefix for the state name None Source code in simulation/states.py def __init__ ( self , name : str , name_prefix : Optional [ str ] = None ): \"\"\" Args: name: The state name name_prefix: A prefix for the state name \"\"\" super () . __init__ ( name , [], name_prefix ) next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: return None ProbabilisticState \u00b6 A state that uses a propability table to select its successor name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state weights: Sequence [ float ] property readonly \u00b6 The weight assigned to the transitions. __init__ ( self , name , transitions , weights , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] The list of transitions required weights Sequence[float] The list of weights to assign to the transitions in probability notation. required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names ValueError If the weights and transitions list lengths do not match ValueError If the given weights do not sum up to 1 Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], weights : Sequence [ float ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transitions: The list of transitions weights: The list of weights to assign to the transitions in probability notation. name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names ValueError: If the weights and transitions list lengths do not match ValueError: If the given weights do not sum up to 1 \"\"\" # initial base properties super () . __init__ ( name , transitions , name_prefix ) # convert weights to cumulative weights self . __weights = weights # verify that given weights and transitions are sound self . __verify_weights () next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: if len ( self . transitions ) > 0 : return np . random . choice ( a = np . array ( self . transitions ), p = self . weights ) return None RoundRobinState \u00b6 name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state __init__ ( self , name , transitions , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] List of transitions to cycle through required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name (str): The state name transitions (List[Transition]): List of transitions to cycle through name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names \"\"\" super () . __init__ ( name , transitions , name_prefix ) self . transition_cycle = cycle ( transitions ) next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: try : return next ( self . transition_cycle ) except StopIteration : return None SequentialState \u00b6 Simple sequential state only having one possible transition name: str inherited property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str inherited property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the state instance. transitions: List [ cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] inherited property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state __init__ ( self , name , transition , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required transition Transition The target transition required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If transition is None Source code in simulation/states.py def __init__ ( self , name : str , transition : Transition , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transition: The target transition name_prefix: A prefix for the state name Raises: ValueError: If transition is None \"\"\" if transition is None : raise ValueError ( \"Transition must not be None\" ) super () . __init__ ( name , [ transition ], name_prefix ) self . __transition = transition next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: return self . __transition State \u00b6 A State contains various transitions to other states name: str property readonly \u00b6 The name (including the prefix) of the state instance Names must be unique within a state machine. name_only: str property readonly \u00b6 The name of the state instance (names must be uniq within a state machine). name_prefix: Optional [ str ] property readonly \u00b6 The name prefix of the state instance. transitions: List [ cr_kyoushi . simulation . transitions . Transition ] property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state transitions_map: Dict [ str , cr_kyoushi . simulation . transitions . Transition ] property readonly \u00b6 List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state __init__ ( self , name , transitions , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] List of possible transitions required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transitions: List of possible transitions name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names \"\"\" self . _name = name self . _transitions = { t . name : t for t in transitions } self . _name_prefix : Optional [ str ] = name_prefix if len ( self . _transitions ) < len ( transitions ): raise ValueError ( \"Transition names must be unique\" ) next ( self , log , context ) \u00b6 Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py @abstractmethod def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: \"\"\"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [`state machine context`][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Args: log: The bound logger initialized with transition specific information context (Context): State machine context which can be used for complex selection logic Returns: The selected [`Transition`][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. \"\"\" ...","title":"States"},{"location":"reference/states/#states-module","text":"","title":"States module"},{"location":"reference/states/#cr_kyoushi.simulation.states","text":"","title":"cr_kyoushi.simulation.states"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState","text":"Special probabilistic state that allows modifaction of weights.","title":"AdaptiveProbabilisticState"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.modifiers","text":"The weight modifiers assigned to the transitions.","title":"modifiers"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.probabilities","text":"The propabilities based on the weights and modifiers","title":"probabilities"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.weights","text":"The weight assigned to the transitions.","title":"weights"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.__init__","text":"Parameters: Name Type Description Default name str The name of the state required transitions List[cr_kyoushi.simulation.transitions.Transition] The list of transitions required weights Sequence[float] The list of weights to assign to the transitions in propability notation required modifiers Optional[Sequence[float]] List of multiplicative modifiers for each weight. Will default to all 1 if not set. None name_prefix Optional[str] A prefix for the state name None Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], weights : Sequence [ float ], modifiers : Optional [ Sequence [ float ]] = None , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The name of the state transitions: The list of transitions weights: The list of weights to assign to the transitions in propability notation modifiers: List of multiplicative modifiers for each weight. Will default to all 1 if not set. name_prefix: A prefix for the state name \"\"\" super () . __init__ ( name , transitions , weights , name_prefix ) if modifiers is None : modifiers = [ 1.0 ] * len ( self . weights ) self . _modifiers = dict ( zip ( transitions , list ( modifiers ))) self . __modifiers_org : Tuple [ float , ... ] = tuple ( self . modifiers )","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.adapt_after","text":"Hook to update the weight modifiers after the transition selection. Parameters: Name Type Description Default log BoundLogger The logger for the sm context required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required selected Optional[cr_kyoushi.simulation.transitions.Transition] The transition selected in this next call required Source code in simulation/states.py def adapt_after ( self , log : BoundLogger , context : Context , selected : Optional [ Transition ], ): \"\"\"Hook to update the weight modifiers after the transition selection. Args: log: The logger for the sm context context: The state machine context selected: The transition selected in this next call \"\"\"","title":"adapt_after()"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.adapt_before","text":"Hook to update the weight modifiers before the transition selection. Parameters: Name Type Description Default log BoundLogger The logger for the sm context required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Source code in simulation/states.py def adapt_before ( self , log : BoundLogger , context : Context ): \"\"\"Hook to update the weight modifiers before the transition selection. Args: log: The logger for the sm context context: The state machine context \"\"\"","title":"adapt_before()"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: if len ( self . transitions ) > 0 : self . adapt_before ( log , context ) selected = np . random . choice ( a = np . array ( self . transitions ), p = self . probabilities ) self . adapt_after ( log , context , selected ) return selected return None","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.AdaptiveProbabilisticState.reset","text":"Resets the modifiers to their original state Source code in simulation/states.py def reset ( self ): \"\"\"Resets the modifiers to their original state\"\"\" self . _modifiers = dict ( zip ( self . transitions , self . __modifiers_org ))","title":"reset()"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState","text":"Simple boolean choice state decides between two transitions","title":"ChoiceState"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.no","text":"The transition that is returned when the decision function returns False","title":"no"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.yes","text":"The transition that is returned when the decision function returns True","title":"yes"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.__init__","text":"Parameters: Name Type Description Default name str The state name required decision_function Callable[[structlog.stdlib.BoundLogger, Union[pydantic.main.BaseModel, Dict[str, Any]]], bool] Context function that decides a yes/no question. required yes Transition The transition to return when the decision function returns True required no Transition The transition to return when the decision function returns False required name_prefix Optional[str] A prefix for the state name None Source code in simulation/states.py def __init__ ( self , name : str , decision_function : Callable [[ BoundLogger , Context ], bool ], yes : Transition , no : Transition , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name decision_function: Context function that decides a yes/no question. yes: The transition to return when the decision function returns `True` no: The transition to return when the decision function returns `False` name_prefix: A prefix for the state name \"\"\" super () . __init__ ( name , [ yes , no ], name_prefix ) self . __decision_function : Callable [ [ BoundLogger , Context ], bool ] = decision_function","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.ChoiceState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: return self . yes if self . __decision_function ( log , context ) else self . no","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState","text":"Special type of probabilistic state using an equal random distribution for all transitions","title":"EquallyRandomState"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.weights","text":"The weight assigned to the transitions.","title":"weights"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.__init__","text":"Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] The list of transitions required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transitions: The list of transitions name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names \"\"\" # create even random distribution probability = 1.0 / len ( transitions ) weights = [ probability for i in range ( 0 , len ( transitions ))] # initialize using super super () . __init__ ( name , transitions , weights , name_prefix )","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.EquallyRandomState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: if len ( self . transitions ) > 0 : return np . random . choice ( a = np . array ( self . transitions ), p = self . weights ) return None","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState","text":"State with not further transitions which can be used as final state of a state machine","title":"FinalState"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.__init__","text":"Parameters: Name Type Description Default name str The state name required name_prefix Optional[str] A prefix for the state name None Source code in simulation/states.py def __init__ ( self , name : str , name_prefix : Optional [ str ] = None ): \"\"\" Args: name: The state name name_prefix: A prefix for the state name \"\"\" super () . __init__ ( name , [], name_prefix )","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.FinalState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: return None","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState","text":"A state that uses a propability table to select its successor","title":"ProbabilisticState"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.weights","text":"The weight assigned to the transitions.","title":"weights"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.__init__","text":"Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] The list of transitions required weights Sequence[float] The list of weights to assign to the transitions in probability notation. required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names ValueError If the weights and transitions list lengths do not match ValueError If the given weights do not sum up to 1 Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], weights : Sequence [ float ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transitions: The list of transitions weights: The list of weights to assign to the transitions in probability notation. name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names ValueError: If the weights and transitions list lengths do not match ValueError: If the given weights do not sum up to 1 \"\"\" # initial base properties super () . __init__ ( name , transitions , name_prefix ) # convert weights to cumulative weights self . __weights = weights # verify that given weights and transitions are sound self . __verify_weights ()","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.ProbabilisticState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: if len ( self . transitions ) > 0 : return np . random . choice ( a = np . array ( self . transitions ), p = self . weights ) return None","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState","text":"","title":"RoundRobinState"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.__init__","text":"Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] List of transitions to cycle through required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name (str): The state name transitions (List[Transition]): List of transitions to cycle through name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names \"\"\" super () . __init__ ( name , transitions , name_prefix ) self . transition_cycle = cycle ( transitions )","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.RoundRobinState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: try : return next ( self . transition_cycle ) except StopIteration : return None","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState","text":"Simple sequential state only having one possible transition","title":"SequentialState"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.__init__","text":"Parameters: Name Type Description Default name str The state name required transition Transition The target transition required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If transition is None Source code in simulation/states.py def __init__ ( self , name : str , transition : Transition , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transition: The target transition name_prefix: A prefix for the state name Raises: ValueError: If transition is None \"\"\" if transition is None : raise ValueError ( \"Transition must not be None\" ) super () . __init__ ( name , [ transition ], name_prefix ) self . __transition = transition","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.SequentialState.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: return self . __transition","title":"next()"},{"location":"reference/states/#cr_kyoushi.simulation.states.State","text":"A State contains various transitions to other states","title":"State"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.name","text":"The name (including the prefix) of the state instance Names must be unique within a state machine.","title":"name"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.name_only","text":"The name of the state instance (names must be uniq within a state machine).","title":"name_only"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.name_prefix","text":"The name prefix of the state instance.","title":"name_prefix"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.transitions","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.transitions_map","text":"List of all possible [ transitions ][cr_kyoushi.simulation.transitions.Transition] originating from this state","title":"transitions_map"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.__init__","text":"Parameters: Name Type Description Default name str The state name required transitions List[cr_kyoushi.simulation.transitions.Transition] List of possible transitions required name_prefix Optional[str] A prefix for the state name None Exceptions: Type Description ValueError If there are transitions with duplicate names Source code in simulation/states.py def __init__ ( self , name : str , transitions : List [ Transition ], name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The state name transitions: List of possible transitions name_prefix: A prefix for the state name Raises: ValueError: If there are transitions with duplicate names \"\"\" self . _name = name self . _transitions = { t . name : t for t in transitions } self . _name_prefix : Optional [ str ] = name_prefix if len ( self . _transitions ) < len ( transitions ): raise ValueError ( \"Transition names must be unique\" )","title":"__init__()"},{"location":"reference/states/#cr_kyoushi.simulation.states.State.next","text":"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [ state machine context ][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required context Union[pydantic.main.BaseModel, Dict[str, Any]] State machine context which can be used for complex selection logic required Returns: Type Description Optional[cr_kyoushi.simulation.transitions.Transition] The selected [ Transition ][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. Source code in simulation/states.py @abstractmethod def next ( self , log : BoundLogger , context : Context ) -> Optional [ Transition ]: \"\"\"Selects the next state transition. The selection logic depends on the state implementation. It might rely on the [`state machine context`][cr_kyoushi.simulation.sm.Statemachine.context] and/or execution environment information to select transitions based on complex conditions. Args: log: The bound logger initialized with transition specific information context (Context): State machine context which can be used for complex selection logic Returns: The selected [`Transition`][cr_kyoushi.simulation.transitions.Transition] or None if no transition is available. \"\"\" ...","title":"next()"},{"location":"reference/transitions/","text":"Transitions module \u00b6 \u00b6 DelayedTransition \u00b6 Abstract DelayedTransition allows configuring skipable pre and post transition execution delays. delay_after: ApproximateFloat property readonly \u00b6 The amount of time in seconds to delay after execution delay_before: ApproximateFloat property readonly \u00b6 The amount of time in seconds to delay before execution name: str inherited property readonly \u00b6 The name of the transition (including the prefix) name_only: str inherited property readonly \u00b6 The name of the transition name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the transition instance. target: Optional [ str ] inherited property readonly \u00b6 The target state of the transition transition_function: TransitionFunction inherited property readonly \u00b6 The transition function __init__ ( self , transition_function , name = None , target = None , delay_before = 0.0 , delay_after = 0.0 , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name Optional[str] The transition name None transition_function TransitionFunction The transition function to call upon execution required target Optional[str] The target state None delay_before Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The pre execution delay to configure 0.0 delay_after Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The post execution delay to configure 0.0 name_prefix Optional[str] A prefix for the transition name None Source code in simulation/transitions.py def __init__ ( self , transition_function : TransitionFunction , name : Optional [ str ] = None , target : Optional [ str ] = None , delay_before : Union [ ApproximateFloat , float ] = 0.0 , delay_after : Union [ ApproximateFloat , float ] = 0.0 , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The transition name transition_function: The transition function to call upon execution target: The target state delay_before: The pre execution delay to configure delay_after: The post execution delay to configure name_prefix: A prefix for the transition name \"\"\" super () . __init__ ( transition_function , name , target , name_prefix ) if isinstance ( delay_before , float ): delay_before = ApproximateFloat . convert ( delay_before ) if isinstance ( delay_after , float ): delay_after = ApproximateFloat . convert ( delay_after ) self . _delay_before = delay_before self . _delay_after = delay_after execute ( self , log , current_state , context ) \u00b6 Delayed transition execution sleeps before and after executing the transition. Both delays can be configured during initialization. The delays use a special [ sleep ][cr_kyoushi.simulation.util.sleep] function that registers a SIGINT signal handler to make it possible to interrupt and skip the sleep phase. Note When running in a terminal press Ctrl + C to fast forward . Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Returns: Type Description Optional[str] The state the machine has moved to Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def execute ( self , log : BoundLogger , current_state : str , context : Context , ) -> Optional [ str ]: \"\"\" Delayed transition execution sleeps before and after executing the transition. Both delays can be configured during initialization. The delays use a special [`sleep`][cr_kyoushi.simulation.util.sleep] function that registers a `SIGINT` signal handler to make it possible to interrupt and skip the sleep phase. !!! Note When running in a terminal press ++ctrl+c++ to *fast forward*. Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context Returns: The state the machine has moved to Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" sleep ( self . delay_before ) next_state = super () . execute ( log , current_state , context ) sleep ( self . delay_after ) return next_state NoopTransition \u00b6 No noperation transition that only changes the current state. name: str inherited property readonly \u00b6 The name of the transition (including the prefix) name_only: str inherited property readonly \u00b6 The name of the transition name_prefix: Optional [ str ] inherited property readonly \u00b6 The name prefix of the transition instance. target: Optional [ str ] inherited property readonly \u00b6 The target state of the transition transition_function: TransitionFunction inherited property readonly \u00b6 The transition function __init__ ( self , name = 'noop' , target = None , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default name str The name of the transition 'noop' target Optional[str] The name of the target state None name_prefix Optional[str] A prefix for the transition name None Source code in simulation/transitions.py def __init__ ( self , name : str = \"noop\" , target : Optional [ str ] = None , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The name of the transition target: The name of the target state name_prefix: A prefix for the transition name \"\"\" super () . __init__ ( noop , name = name , target = target , name_prefix = name_prefix ) execute ( self , log , current_state , context ) inherited \u00b6 Transition execution function called by the state machine. The default behavior is to directly call the configured [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function] Info This function can be overridden or extended to change how transitions are executed. Actual transition implementations should be done via the supplied [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function]. Warning Don't forget to call super () . execute ( current_state , context ) or self . transition_function ( current_state , context ) . Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Returns: Type Description Optional[str] The state the machine has moved to Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def execute ( self , log : BoundLogger , current_state : str , context : Context , ) -> Optional [ str ]: \"\"\"Transition execution function called by the state machine. The default behavior is to directly call the configured [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function] !!! Info This function can be overridden or extended to change **how** transitions are executed. Actual transition implementations should be done via the supplied [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function]. !!! Warning Don't forget to call `#!python super().execute(current_state, context)` or `#!python self.transition_function(current_state, context)`. Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context Returns: The state the machine has moved to Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" self . transition_function ( log , current_state , context , self . target ) return self . target Transition \u00b6 Abstract base Transition class describes a transition from one state into another name: str property readonly \u00b6 The name of the transition (including the prefix) name_only: str property readonly \u00b6 The name of the transition name_prefix: Optional [ str ] property readonly \u00b6 The name prefix of the transition instance. target: Optional [ str ] property readonly \u00b6 The target state of the transition transition_function: TransitionFunction property readonly \u00b6 The transition function __init__ ( self , transition_function , name = None , target = None , name_prefix = None ) special \u00b6 Parameters: Name Type Description Default transition_function TransitionFunction The transition function to call upon execution required name Optional[str] The transition name None target Optional[str] The target state None name_prefix Optional[str] A prefix for the transition name None Source code in simulation/transitions.py def __init__ ( self , transition_function : TransitionFunction , name : Optional [ str ] = None , target : Optional [ str ] = None , name_prefix : Optional [ str ] = None , ): \"\"\" Args: transition_function: The transition function to call upon execution name: The transition name target: The target state name_prefix: A prefix for the transition name \"\"\" if name is None : if isinstance ( transition_function , FunctionType ): name = transition_function . __name__ . lower () else : name = transition_function . __class__ . __name__ . lower () self . _transition_function : TransitionFunction = transition_function self . _name : str = name self . _name_prefix : Optional [ str ] = name_prefix self . _target : Optional [ str ] = target execute ( self , log , current_state , context ) \u00b6 Transition execution function called by the state machine. The default behavior is to directly call the configured [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function] Info This function can be overridden or extended to change how transitions are executed. Actual transition implementations should be done via the supplied [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function]. Warning Don't forget to call super () . execute ( current_state , context ) or self . transition_function ( current_state , context ) . Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Returns: Type Description Optional[str] The state the machine has moved to Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def execute ( self , log : BoundLogger , current_state : str , context : Context , ) -> Optional [ str ]: \"\"\"Transition execution function called by the state machine. The default behavior is to directly call the configured [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function] !!! Info This function can be overridden or extended to change **how** transitions are executed. Actual transition implementations should be done via the supplied [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function]. !!! Warning Don't forget to call `#!python super().execute(current_state, context)` or `#!python self.transition_function(current_state, context)`. Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context Returns: The state the machine has moved to Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" self . transition_function ( log , current_state , context , self . target ) return self . target TransitionFunction \u00b6 __call__ ( self , log , current_state , context , target ) special \u00b6 Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required target Optional[str] The target state required Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def __call__ ( self , log : BoundLogger , current_state : str , context : Context , target : Optional [ str ], ): \"\"\" Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context target: The target state Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" delayed_transition ( name = None , target = None , delay_before = 0.0 , delay_after = 0.0 , name_prefix = None ) \u00b6 Transition decorator that can be used to turn a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a [ DelayedTransition ][cr_kyoushi.simulation.transitions.DelayedTransition]. Parameters: Name Type Description Default name Optional[str] The name of the transition None target Optional[str] The target states name None delay_before Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The pre execution delay to configure 0.0 delay_after Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The post execution delay to configure 0.0 name_prefix Optional[str] A prefix for the transition name None Examples: @delayed_transition ( name = \"example\" , target = \"next\" , delay_before = 1.5 ) def example ( current_state , context , target ): ... # the above is equivalent to def example_func ( current_state , context , target ): ... example = DelayedTransition ( example_func , name = \"example\" , target = \"next\" , delay_before = 1.5 ) Returns: Type Description Callable[[cr_kyoushi.simulation.transitions.TransitionFunction], cr_kyoushi.simulation.transitions.DelayedTransition] A decorator that turns a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a DelayedTransition initialized with the given args. Source code in simulation/transitions.py def delayed_transition ( name : Optional [ str ] = None , target : Optional [ str ] = None , delay_before : Union [ ApproximateFloat , float ] = 0.0 , delay_after : Union [ ApproximateFloat , float ] = 0.0 , name_prefix : Optional [ str ] = None , ) -> Callable [[ TransitionFunction ], DelayedTransition ]: \"\"\"Transition decorator that can be used to turn a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a [`DelayedTransition`][cr_kyoushi.simulation.transitions.DelayedTransition]. Args: name: The name of the transition target: The target states name delay_before: The pre execution delay to configure delay_after: The post execution delay to configure name_prefix: A prefix for the transition name Example: ```python @delayed_transition(name=\"example\", target=\"next\", delay_before=1.5) def example(current_state, context, target): ... # the above is equivalent to def example_func(current_state, context, target): ... example = DelayedTransition(example_func, name=\"example\", target=\"next\", delay_before=1.5) ``` Returns: A decorator that turns a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a DelayedTransition initialized with the given args. \"\"\" def decorator ( func : TransitionFunction ) -> DelayedTransition : return DelayedTransition ( transition_function = func , target = target , name = name , delay_before = delay_before , delay_after = delay_after , name_prefix = name_prefix , ) return decorator noop ( log , current_state , context , target ) \u00b6 No operation transition function Source code in simulation/transitions.py def noop ( log : BoundLogger , current_state : str , context : Context , target : Optional [ str ]): \"\"\"No operation transition function\"\"\" transition ( name = None , target = None , name_prefix = None ) \u00b6 Transition decorator that can be used to turn a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a [ Transition ][cr_kyoushi.simulation.transitions.Transition]. Parameters: Name Type Description Default name Optional[str] The name of the transition None target Optional[str] The target states name None name_prefix Optional[str] A prefix for the transition name None Examples: @transition ( name = \"example\" , target = \"next\" ) def example ( current_state , context , target ): ... # the above is equivalent to def example_func ( current_state , context , target ): ... example = Transition ( example_func , name = \"example\" , target = \"next\" ) Returns: Type Description Callable[[cr_kyoushi.simulation.transitions.TransitionFunction], cr_kyoushi.simulation.transitions.Transition] A decorator that turns a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a Transition initialized with the given args. Source code in simulation/transitions.py def transition ( name : Optional [ str ] = None , target : Optional [ str ] = None , name_prefix : Optional [ str ] = None , ) -> Callable [[ TransitionFunction ], Transition ]: \"\"\"Transition decorator that can be used to turn a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a [`Transition`][cr_kyoushi.simulation.transitions.Transition]. Args: name: The name of the transition target: The target states name name_prefix: A prefix for the transition name Example: ```python @transition(name=\"example\", target=\"next\") def example(current_state, context, target): ... # the above is equivalent to def example_func(current_state, context, target): ... example = Transition(example_func, name=\"example\", target=\"next\") ``` Returns: A decorator that turns a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a Transition initialized with the given args. \"\"\" def decorator ( func : TransitionFunction ) -> Transition : return Transition ( transition_function = func , target = target , name = name , name_prefix = name_prefix ) return decorator","title":"Transitions"},{"location":"reference/transitions/#transitions-module","text":"","title":"Transitions module"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions","text":"","title":"cr_kyoushi.simulation.transitions"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition","text":"Abstract DelayedTransition allows configuring skipable pre and post transition execution delays.","title":"DelayedTransition"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.delay_after","text":"The amount of time in seconds to delay after execution","title":"delay_after"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.delay_before","text":"The amount of time in seconds to delay before execution","title":"delay_before"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.name","text":"The name of the transition (including the prefix)","title":"name"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.name_only","text":"The name of the transition","title":"name_only"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.name_prefix","text":"The name prefix of the transition instance.","title":"name_prefix"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.target","text":"The target state of the transition","title":"target"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.transition_function","text":"The transition function","title":"transition_function"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.__init__","text":"Parameters: Name Type Description Default name Optional[str] The transition name None transition_function TransitionFunction The transition function to call upon execution required target Optional[str] The target state None delay_before Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The pre execution delay to configure 0.0 delay_after Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The post execution delay to configure 0.0 name_prefix Optional[str] A prefix for the transition name None Source code in simulation/transitions.py def __init__ ( self , transition_function : TransitionFunction , name : Optional [ str ] = None , target : Optional [ str ] = None , delay_before : Union [ ApproximateFloat , float ] = 0.0 , delay_after : Union [ ApproximateFloat , float ] = 0.0 , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The transition name transition_function: The transition function to call upon execution target: The target state delay_before: The pre execution delay to configure delay_after: The post execution delay to configure name_prefix: A prefix for the transition name \"\"\" super () . __init__ ( transition_function , name , target , name_prefix ) if isinstance ( delay_before , float ): delay_before = ApproximateFloat . convert ( delay_before ) if isinstance ( delay_after , float ): delay_after = ApproximateFloat . convert ( delay_after ) self . _delay_before = delay_before self . _delay_after = delay_after","title":"__init__()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.DelayedTransition.execute","text":"Delayed transition execution sleeps before and after executing the transition. Both delays can be configured during initialization. The delays use a special [ sleep ][cr_kyoushi.simulation.util.sleep] function that registers a SIGINT signal handler to make it possible to interrupt and skip the sleep phase. Note When running in a terminal press Ctrl + C to fast forward . Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Returns: Type Description Optional[str] The state the machine has moved to Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def execute ( self , log : BoundLogger , current_state : str , context : Context , ) -> Optional [ str ]: \"\"\" Delayed transition execution sleeps before and after executing the transition. Both delays can be configured during initialization. The delays use a special [`sleep`][cr_kyoushi.simulation.util.sleep] function that registers a `SIGINT` signal handler to make it possible to interrupt and skip the sleep phase. !!! Note When running in a terminal press ++ctrl+c++ to *fast forward*. Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context Returns: The state the machine has moved to Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" sleep ( self . delay_before ) next_state = super () . execute ( log , current_state , context ) sleep ( self . delay_after ) return next_state","title":"execute()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition","text":"No noperation transition that only changes the current state.","title":"NoopTransition"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.name","text":"The name of the transition (including the prefix)","title":"name"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.name_only","text":"The name of the transition","title":"name_only"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.name_prefix","text":"The name prefix of the transition instance.","title":"name_prefix"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.target","text":"The target state of the transition","title":"target"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.transition_function","text":"The transition function","title":"transition_function"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.__init__","text":"Parameters: Name Type Description Default name str The name of the transition 'noop' target Optional[str] The name of the target state None name_prefix Optional[str] A prefix for the transition name None Source code in simulation/transitions.py def __init__ ( self , name : str = \"noop\" , target : Optional [ str ] = None , name_prefix : Optional [ str ] = None , ): \"\"\" Args: name: The name of the transition target: The name of the target state name_prefix: A prefix for the transition name \"\"\" super () . __init__ ( noop , name = name , target = target , name_prefix = name_prefix )","title":"__init__()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.NoopTransition.execute","text":"Transition execution function called by the state machine. The default behavior is to directly call the configured [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function] Info This function can be overridden or extended to change how transitions are executed. Actual transition implementations should be done via the supplied [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function]. Warning Don't forget to call super () . execute ( current_state , context ) or self . transition_function ( current_state , context ) . Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Returns: Type Description Optional[str] The state the machine has moved to Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def execute ( self , log : BoundLogger , current_state : str , context : Context , ) -> Optional [ str ]: \"\"\"Transition execution function called by the state machine. The default behavior is to directly call the configured [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function] !!! Info This function can be overridden or extended to change **how** transitions are executed. Actual transition implementations should be done via the supplied [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function]. !!! Warning Don't forget to call `#!python super().execute(current_state, context)` or `#!python self.transition_function(current_state, context)`. Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context Returns: The state the machine has moved to Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" self . transition_function ( log , current_state , context , self . target ) return self . target","title":"execute()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition","text":"Abstract base Transition class describes a transition from one state into another","title":"Transition"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.name","text":"The name of the transition (including the prefix)","title":"name"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.name_only","text":"The name of the transition","title":"name_only"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.name_prefix","text":"The name prefix of the transition instance.","title":"name_prefix"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.target","text":"The target state of the transition","title":"target"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.transition_function","text":"The transition function","title":"transition_function"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.__init__","text":"Parameters: Name Type Description Default transition_function TransitionFunction The transition function to call upon execution required name Optional[str] The transition name None target Optional[str] The target state None name_prefix Optional[str] A prefix for the transition name None Source code in simulation/transitions.py def __init__ ( self , transition_function : TransitionFunction , name : Optional [ str ] = None , target : Optional [ str ] = None , name_prefix : Optional [ str ] = None , ): \"\"\" Args: transition_function: The transition function to call upon execution name: The transition name target: The target state name_prefix: A prefix for the transition name \"\"\" if name is None : if isinstance ( transition_function , FunctionType ): name = transition_function . __name__ . lower () else : name = transition_function . __class__ . __name__ . lower () self . _transition_function : TransitionFunction = transition_function self . _name : str = name self . _name_prefix : Optional [ str ] = name_prefix self . _target : Optional [ str ] = target","title":"__init__()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.Transition.execute","text":"Transition execution function called by the state machine. The default behavior is to directly call the configured [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function] Info This function can be overridden or extended to change how transitions are executed. Actual transition implementations should be done via the supplied [ transition_function ][cr_kyoushi.simulation.transitions.Transition.transition_function]. Warning Don't forget to call super () . execute ( current_state , context ) or self . transition_function ( current_state , context ) . Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required Returns: Type Description Optional[str] The state the machine has moved to Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def execute ( self , log : BoundLogger , current_state : str , context : Context , ) -> Optional [ str ]: \"\"\"Transition execution function called by the state machine. The default behavior is to directly call the configured [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function] !!! Info This function can be overridden or extended to change **how** transitions are executed. Actual transition implementations should be done via the supplied [`transition_function`][cr_kyoushi.simulation.transitions.Transition.transition_function]. !!! Warning Don't forget to call `#!python super().execute(current_state, context)` or `#!python self.transition_function(current_state, context)`. Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context Returns: The state the machine has moved to Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\" self . transition_function ( log , current_state , context , self . target ) return self . target","title":"execute()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.TransitionFunction","text":"","title":"TransitionFunction"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.TransitionFunction.__call__","text":"Parameters: Name Type Description Default log BoundLogger The bound logger initialized with transition specific information required current_state str The calling states name required context Union[pydantic.main.BaseModel, Dict[str, Any]] The state machine context required target Optional[str] The target state required Exceptions: Type Description TransitionExecutionError If a transition error occurs for which we can fallback into a valid state Source code in simulation/transitions.py def __call__ ( self , log : BoundLogger , current_state : str , context : Context , target : Optional [ str ], ): \"\"\" Args: log: The bound logger initialized with transition specific information current_state: The calling states name context: The state machine context target: The target state Raises: TransitionExecutionError: If a transition error occurs for which we can fallback into a valid state \"\"\"","title":"__call__()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.delayed_transition","text":"Transition decorator that can be used to turn a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a [ DelayedTransition ][cr_kyoushi.simulation.transitions.DelayedTransition]. Parameters: Name Type Description Default name Optional[str] The name of the transition None target Optional[str] The target states name None delay_before Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The pre execution delay to configure 0.0 delay_after Union[cr_kyoushi.simulation.model.ApproximateFloat, float] The post execution delay to configure 0.0 name_prefix Optional[str] A prefix for the transition name None Examples: @delayed_transition ( name = \"example\" , target = \"next\" , delay_before = 1.5 ) def example ( current_state , context , target ): ... # the above is equivalent to def example_func ( current_state , context , target ): ... example = DelayedTransition ( example_func , name = \"example\" , target = \"next\" , delay_before = 1.5 ) Returns: Type Description Callable[[cr_kyoushi.simulation.transitions.TransitionFunction], cr_kyoushi.simulation.transitions.DelayedTransition] A decorator that turns a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a DelayedTransition initialized with the given args. Source code in simulation/transitions.py def delayed_transition ( name : Optional [ str ] = None , target : Optional [ str ] = None , delay_before : Union [ ApproximateFloat , float ] = 0.0 , delay_after : Union [ ApproximateFloat , float ] = 0.0 , name_prefix : Optional [ str ] = None , ) -> Callable [[ TransitionFunction ], DelayedTransition ]: \"\"\"Transition decorator that can be used to turn a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a [`DelayedTransition`][cr_kyoushi.simulation.transitions.DelayedTransition]. Args: name: The name of the transition target: The target states name delay_before: The pre execution delay to configure delay_after: The post execution delay to configure name_prefix: A prefix for the transition name Example: ```python @delayed_transition(name=\"example\", target=\"next\", delay_before=1.5) def example(current_state, context, target): ... # the above is equivalent to def example_func(current_state, context, target): ... example = DelayedTransition(example_func, name=\"example\", target=\"next\", delay_before=1.5) ``` Returns: A decorator that turns a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a DelayedTransition initialized with the given args. \"\"\" def decorator ( func : TransitionFunction ) -> DelayedTransition : return DelayedTransition ( transition_function = func , target = target , name = name , delay_before = delay_before , delay_after = delay_after , name_prefix = name_prefix , ) return decorator","title":"delayed_transition()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.noop","text":"No operation transition function Source code in simulation/transitions.py def noop ( log : BoundLogger , current_state : str , context : Context , target : Optional [ str ]): \"\"\"No operation transition function\"\"\"","title":"noop()"},{"location":"reference/transitions/#cr_kyoushi.simulation.transitions.transition","text":"Transition decorator that can be used to turn a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a [ Transition ][cr_kyoushi.simulation.transitions.Transition]. Parameters: Name Type Description Default name Optional[str] The name of the transition None target Optional[str] The target states name None name_prefix Optional[str] A prefix for the transition name None Examples: @transition ( name = \"example\" , target = \"next\" ) def example ( current_state , context , target ): ... # the above is equivalent to def example_func ( current_state , context , target ): ... example = Transition ( example_func , name = \"example\" , target = \"next\" ) Returns: Type Description Callable[[cr_kyoushi.simulation.transitions.TransitionFunction], cr_kyoushi.simulation.transitions.Transition] A decorator that turns a [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] into a Transition initialized with the given args. Source code in simulation/transitions.py def transition ( name : Optional [ str ] = None , target : Optional [ str ] = None , name_prefix : Optional [ str ] = None , ) -> Callable [[ TransitionFunction ], Transition ]: \"\"\"Transition decorator that can be used to turn a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a [`Transition`][cr_kyoushi.simulation.transitions.Transition]. Args: name: The name of the transition target: The target states name name_prefix: A prefix for the transition name Example: ```python @transition(name=\"example\", target=\"next\") def example(current_state, context, target): ... # the above is equivalent to def example_func(current_state, context, target): ... example = Transition(example_func, name=\"example\", target=\"next\") ``` Returns: A decorator that turns a [`TransitionFunction`][cr_kyoushi.simulation.transitions.TransitionFunction] into a Transition initialized with the given args. \"\"\" def decorator ( func : TransitionFunction ) -> Transition : return Transition ( transition_function = func , target = target , name = name , name_prefix = name_prefix ) return decorator","title":"transition()"},{"location":"reference/util/","text":"Util module \u00b6 \u00b6 Statemachine util module This module contains some utility functions which can used for statemachines, state and state transitions. calculate_propabilities ( weights , modifiers ) \u00b6 Calculates the propability distribution from a list of weights and modifiers. Parameters: Name Type Description Default weights Sequence[float] The base weights required modifiers Sequence[float] The weight modifiers required Exceptions: Type Description ValueError If the len of weights and modifiers do not match If the resulting propabilities do not sum to 1 Returns: Type Description List[float] The modified weights as propabilities Source code in simulation/util.py def calculate_propabilities ( weights : Sequence [ float ], modifiers : Sequence [ float ], ) -> List [ float ]: \"\"\"Calculates the propability distribution from a list of weights and modifiers. Args: weights: The base weights modifiers: The weight modifiers Raises: ValueError: If the len of weights and modifiers do not match If the resulting propabilities do not sum to 1 Returns: The modified weights as propabilities \"\"\" if len ( weights ) != len ( modifiers ): raise ValueError ( \"The len of weights and modifieres do not match!\" ) if abs ( 1.0 - sum ( weights )) > 1e-8 : raise ValueError ( \"The weights must sum up to 1\" ) if any ( w < 0 for w in weights ) or any ( m < 0 for m in modifiers ): raise ValueError ( \"Weights and modifiers must be positive values\" ) return normalize_propabilities ( [ w * m for w , m in zip ( weights , modifiers )], # weights[*] and modifiers[*] > 0 already guarantees this check_positive = False , ) elements_unique ( to_check ) \u00b6 Utility function to check if elements in a list are uniq. Parameters: Name Type Description Default to_check List[Any] The list to check required Returns: Type Description bool True if the list contains no duplicates False otherwise. Source code in simulation/util.py def elements_unique ( to_check : List [ Any ]) -> bool : \"\"\"Utility function to check if elements in a list are uniq. Args: to_check: The list to check Returns: `True` if the list contains no duplicates `False` otherwise. \"\"\" seen = set () return not any ( i in seen or seen . add ( i ) for i in to_check ) # type: ignore normalize_propabilities ( propabilities , check_positive = True ) \u00b6 Normalizes a propability distribution to sum up to 1. Has a floating point error tolerance of up to 1e-8 (same as numpy.choice). If the resulting difference is greater than 1e-8 it is added to the first non zero propability. Parameters: Name Type Description Default propabilities Sequence[float] The distribution to normalize required check_positive bool Switch to disable the positive number test. This makes the function slightly faster True Exceptions: Type Description ValueError If the distribution sums to 0 or If one of the propability values is negative Returns: Type Description List[float] List[float]: [description] Source code in simulation/util.py def normalize_propabilities ( propabilities : Sequence [ float ], check_positive : bool = True ) -> List [ float ]: \"\"\"Normalizes a propability distribution to sum up to 1. Has a floating point error tolerance of up to 1e-8 (same as numpy.choice). If the resulting difference is greater than 1e-8 it is added to the first non zero propability. Args: propabilities: The distribution to normalize check_positive: Switch to disable the positive number test. This makes the function slightly faster Raises: ValueError: If the distribution sums to 0 or If one of the propability values is negative Returns: List[float]: [description] \"\"\" # only check when requested if check_positive and any ( p < 0 for p in propabilities ): raise ValueError ( \"Propabilities must be positive numbers\" ) total = sum ( propabilities ) if total > 0 : multiplier = 1.0 / total propabilities = [ p * multiplier for p in propabilities ] diff = 1.0 - sum ( propabilities ) # when rounding errors become to extrem # then we fix them by adding the diff to 1 a propability if abs ( diff ) > 1e-8 : # first non 0 propability index will be increased adjust_index = next (( i for i , x in enumerate ( propabilities ) if x != 0.0 )) propabilities [ adjust_index ] += diff return propabilities raise ValueError ( \"Resulting propabilities sum to 0\" ) now ( tz = None ) \u00b6 Utility function for getting the current datetime. For statemachine features that require the current time it is preferred to use this function instead of datetime.now() directly. This suggested because datetime is a builtin and a such cannot easily be mocked during tests. Parameters: Name Type Description Default tz Optional[tzinfo] Optionally the timezone to use None Source code in simulation/util.py def now ( tz : Optional [ tzinfo ] = None ) -> datetime : \"\"\"Utility function for getting the current datetime. For statemachine features that require the current time it is preferred to use this function instead of `datetime.now()` directly. This suggested because `datetime` is a builtin and a such cannot easily be mocked during tests. Args: tz: Optionally the timezone to use \"\"\" return datetime . now ( tz ) skip_on_interrupt ( sig =< Signals . SIGINT : 2 > , sig_handler =< function skip_on_interrupt_sig_handler at 0x7fdfa0e4ff80 > ) \u00b6 Context manager for creating skipable code sections. Parameters: Name Type Description Default sig signal.Signals The signal that should indicate a skip request. <Signals.SIGINT: 2> sig_handler Callable[[signal.Signals, FrameType], None] The skip on signal handler to use. <function skip_on_interrupt_sig_handler at 0x7fdfa0e4ff80> Examples: # start of the skipable section with skip_on_interrupt (): ... long_running_task () ... # after a skip we resume here ... Source code in simulation/util.py @contextmanager def skip_on_interrupt ( sig : signal . Signals = signal . SIGINT , sig_handler : Callable [ [ signal . Signals , FrameType ], None ] = skip_on_interrupt_sig_handler , ): \"\"\"Context manager for creating skipable code sections. Args: sig: The signal that should indicate a skip request. sig_handler: The skip on signal handler to use. Example: ```python # start of the skipable section with skip_on_interrupt(): ... long_running_task() ... # after a skip we resume here ... ``` \"\"\" try : original_handler = signal . getsignal ( sig ) signal . signal ( sig , sig_handler ) yield except SkipSectionError : log . debug ( \"Skipped section\" ) signal . signal ( sig , original_handler ) # clear original signal handler so we know not to # reset to it twice original_handler = None print ( \"Press CTRL+C again to stop the program\" ) time . sleep ( 0.5 ) finally : if original_handler is not None : signal . signal ( sig , original_handler ) skip_on_interrupt_sig_handler ( signum , frame ) \u00b6 Simple signal handler that just raises a [ SkipSectionError ][cr_kyoushi.simulation.errors.SkipSectionError] when it receives a interrupt signal. Exceptions: Type Description SkipSectionError To indicate the current section should be skipped Source code in simulation/util.py def skip_on_interrupt_sig_handler ( signum : signal . Signals , frame : FrameType ): \"\"\"Simple signal handler that just raises a [`SkipSectionError`][cr_kyoushi.simulation.errors.SkipSectionError] when it receives a interrupt signal. Raises: SkipSectionError: To indicate the current section should be skipped \"\"\" log . debug ( \"Received interrupt raising skip section error\" ) raise SkipSectionError () sleep ( sleep_time ) \u00b6 Skipable sleep function This function utilizes the [ skip_on_interrupt ][cr_kyoushi.simulation.util.skip_on_interrupt] context manager to implement a skipable sleep. SIGINT is used used as skip signal. For CLI applications simply press Ctrl + C to skip to interrupt the sleep. Note If you wish to send the SIGINT signal to the main process press Ctrl + C twice. Source code in simulation/util.py def sleep ( sleep_time : Union [ ApproximateFloat , float ]) -> None : \"\"\"Skipable sleep function This function utilizes the [`skip_on_interrupt`][cr_kyoushi.simulation.util.skip_on_interrupt] context manager to implement a skipable sleep. `SIGINT` is used used as skip signal. For CLI applications simply press ++ctrl+c++ to skip to interrupt the sleep. !!! Note If you wish to send the `SIGINT` signal to the main process press ++ctrl+c++ twice. \"\"\" if isinstance ( sleep_time , ApproximateFloat ): sleep_time = sleep_time . value with skip_on_interrupt (): log . debug ( \"Going to sleep for %f \" , sleep_time ) time . sleep ( sleep_time ) log . debug ( \"Resuming execution after sleeping for %f \" , sleep_time ) sleep_until ( end_datetime , min_sleep_amount = 0.1 , sleep_amount = None ) \u00b6 Sleep until specified datetime The default behavior is to basically binary search towards the target datetime. i.e., the sleep duration is always time left/2 until min sleep amount is larger than the division result. Alternatively fixed sleep steps can be configured. Hint You can interupt the current sleep and check if the desired datetime is already reached by pressing Ctrl + C and sending a SIGINT . Parameters: Name Type Description Default end_datetime datetime The datetime to wait until required min_sleep_amount float The minimum amount of time sleep in between checks. 0.1 sleep_amount Optional[Union[float, ApproximateFloat]] Optionally use fixed amount of time sleep steps None Source code in simulation/util.py def sleep_until ( end_datetime : datetime , min_sleep_amount : float = 0.1 , sleep_amount : Optional [ Union [ float , ApproximateFloat ]] = None , ): \"\"\"Sleep until specified datetime The default behavior is to basically binary search towards the target datetime. i.e., the sleep duration is always `time left/2` until min sleep amount is larger than the division result. Alternatively fixed sleep steps can be configured. !!! Hint You can interupt the current sleep and check if the desired datetime is already reached by pressing ++ctrl+c++ and sending a `SIGINT`. Args: end_datetime: The datetime to wait until min_sleep_amount: The minimum amount of time sleep in between checks. sleep_amount: Optionally use fixed amount of time sleep steps \"\"\" while True : diff = ( end_datetime - now ()) . total_seconds () # stop waiting once its the end time or later if diff <= 0 : return # if we do not have a sleep interval sleep relative to # the time between now and the end time if sleep_amount is None : # to avoid many extremely short sleeps # fallback to the minimum sleep sleep ( max ( min_sleep_amount , diff / 2 )) else : sleep ( sleep_amount ) version_info ( cli_info ) \u00b6 Returns formatted version information about the cr_kyoushi.simulation package . Adapted from Pydantic version.py Source code in simulation/util.py def version_info ( cli_info : Info ) -> str : \"\"\"Returns formatted version information about the `cr_kyoushi.simulation package`. Adapted from [Pydantic version.py](https://github.com/samuelcolvin/pydantic/blob/master/pydantic/version.py) \"\"\" import platform import sys from pathlib import Path from . import __version__ info = { \"cr_kyoushi.simulation version\" : __version__ , \"config path\" : cli_info . settings_path . absolute () if cli_info . settings_path is not None else None , \"install path\" : Path ( __file__ ) . resolve () . parent , \"python version\" : sys . version , \"platform\" : platform . platform (), } return \" \\n \" . join ( \" {:>30} {} \" . format ( k + \":\" , str ( v ) . replace ( \" \\n \" , \" \" )) for k , v in info . items () )","title":"Utility Functions"},{"location":"reference/util/#util-module","text":"","title":"Util module"},{"location":"reference/util/#cr_kyoushi.simulation.util","text":"Statemachine util module This module contains some utility functions which can used for statemachines, state and state transitions.","title":"cr_kyoushi.simulation.util"},{"location":"reference/util/#cr_kyoushi.simulation.util.calculate_propabilities","text":"Calculates the propability distribution from a list of weights and modifiers. Parameters: Name Type Description Default weights Sequence[float] The base weights required modifiers Sequence[float] The weight modifiers required Exceptions: Type Description ValueError If the len of weights and modifiers do not match If the resulting propabilities do not sum to 1 Returns: Type Description List[float] The modified weights as propabilities Source code in simulation/util.py def calculate_propabilities ( weights : Sequence [ float ], modifiers : Sequence [ float ], ) -> List [ float ]: \"\"\"Calculates the propability distribution from a list of weights and modifiers. Args: weights: The base weights modifiers: The weight modifiers Raises: ValueError: If the len of weights and modifiers do not match If the resulting propabilities do not sum to 1 Returns: The modified weights as propabilities \"\"\" if len ( weights ) != len ( modifiers ): raise ValueError ( \"The len of weights and modifieres do not match!\" ) if abs ( 1.0 - sum ( weights )) > 1e-8 : raise ValueError ( \"The weights must sum up to 1\" ) if any ( w < 0 for w in weights ) or any ( m < 0 for m in modifiers ): raise ValueError ( \"Weights and modifiers must be positive values\" ) return normalize_propabilities ( [ w * m for w , m in zip ( weights , modifiers )], # weights[*] and modifiers[*] > 0 already guarantees this check_positive = False , )","title":"calculate_propabilities()"},{"location":"reference/util/#cr_kyoushi.simulation.util.elements_unique","text":"Utility function to check if elements in a list are uniq. Parameters: Name Type Description Default to_check List[Any] The list to check required Returns: Type Description bool True if the list contains no duplicates False otherwise. Source code in simulation/util.py def elements_unique ( to_check : List [ Any ]) -> bool : \"\"\"Utility function to check if elements in a list are uniq. Args: to_check: The list to check Returns: `True` if the list contains no duplicates `False` otherwise. \"\"\" seen = set () return not any ( i in seen or seen . add ( i ) for i in to_check ) # type: ignore","title":"elements_unique()"},{"location":"reference/util/#cr_kyoushi.simulation.util.normalize_propabilities","text":"Normalizes a propability distribution to sum up to 1. Has a floating point error tolerance of up to 1e-8 (same as numpy.choice). If the resulting difference is greater than 1e-8 it is added to the first non zero propability. Parameters: Name Type Description Default propabilities Sequence[float] The distribution to normalize required check_positive bool Switch to disable the positive number test. This makes the function slightly faster True Exceptions: Type Description ValueError If the distribution sums to 0 or If one of the propability values is negative Returns: Type Description List[float] List[float]: [description] Source code in simulation/util.py def normalize_propabilities ( propabilities : Sequence [ float ], check_positive : bool = True ) -> List [ float ]: \"\"\"Normalizes a propability distribution to sum up to 1. Has a floating point error tolerance of up to 1e-8 (same as numpy.choice). If the resulting difference is greater than 1e-8 it is added to the first non zero propability. Args: propabilities: The distribution to normalize check_positive: Switch to disable the positive number test. This makes the function slightly faster Raises: ValueError: If the distribution sums to 0 or If one of the propability values is negative Returns: List[float]: [description] \"\"\" # only check when requested if check_positive and any ( p < 0 for p in propabilities ): raise ValueError ( \"Propabilities must be positive numbers\" ) total = sum ( propabilities ) if total > 0 : multiplier = 1.0 / total propabilities = [ p * multiplier for p in propabilities ] diff = 1.0 - sum ( propabilities ) # when rounding errors become to extrem # then we fix them by adding the diff to 1 a propability if abs ( diff ) > 1e-8 : # first non 0 propability index will be increased adjust_index = next (( i for i , x in enumerate ( propabilities ) if x != 0.0 )) propabilities [ adjust_index ] += diff return propabilities raise ValueError ( \"Resulting propabilities sum to 0\" )","title":"normalize_propabilities()"},{"location":"reference/util/#cr_kyoushi.simulation.util.now","text":"Utility function for getting the current datetime. For statemachine features that require the current time it is preferred to use this function instead of datetime.now() directly. This suggested because datetime is a builtin and a such cannot easily be mocked during tests. Parameters: Name Type Description Default tz Optional[tzinfo] Optionally the timezone to use None Source code in simulation/util.py def now ( tz : Optional [ tzinfo ] = None ) -> datetime : \"\"\"Utility function for getting the current datetime. For statemachine features that require the current time it is preferred to use this function instead of `datetime.now()` directly. This suggested because `datetime` is a builtin and a such cannot easily be mocked during tests. Args: tz: Optionally the timezone to use \"\"\" return datetime . now ( tz )","title":"now()"},{"location":"reference/util/#cr_kyoushi.simulation.util.skip_on_interrupt","text":"Context manager for creating skipable code sections. Parameters: Name Type Description Default sig signal.Signals The signal that should indicate a skip request. <Signals.SIGINT: 2> sig_handler Callable[[signal.Signals, FrameType], None] The skip on signal handler to use. <function skip_on_interrupt_sig_handler at 0x7fdfa0e4ff80> Examples: # start of the skipable section with skip_on_interrupt (): ... long_running_task () ... # after a skip we resume here ... Source code in simulation/util.py @contextmanager def skip_on_interrupt ( sig : signal . Signals = signal . SIGINT , sig_handler : Callable [ [ signal . Signals , FrameType ], None ] = skip_on_interrupt_sig_handler , ): \"\"\"Context manager for creating skipable code sections. Args: sig: The signal that should indicate a skip request. sig_handler: The skip on signal handler to use. Example: ```python # start of the skipable section with skip_on_interrupt(): ... long_running_task() ... # after a skip we resume here ... ``` \"\"\" try : original_handler = signal . getsignal ( sig ) signal . signal ( sig , sig_handler ) yield except SkipSectionError : log . debug ( \"Skipped section\" ) signal . signal ( sig , original_handler ) # clear original signal handler so we know not to # reset to it twice original_handler = None print ( \"Press CTRL+C again to stop the program\" ) time . sleep ( 0.5 ) finally : if original_handler is not None : signal . signal ( sig , original_handler )","title":"skip_on_interrupt()"},{"location":"reference/util/#cr_kyoushi.simulation.util.skip_on_interrupt_sig_handler","text":"Simple signal handler that just raises a [ SkipSectionError ][cr_kyoushi.simulation.errors.SkipSectionError] when it receives a interrupt signal. Exceptions: Type Description SkipSectionError To indicate the current section should be skipped Source code in simulation/util.py def skip_on_interrupt_sig_handler ( signum : signal . Signals , frame : FrameType ): \"\"\"Simple signal handler that just raises a [`SkipSectionError`][cr_kyoushi.simulation.errors.SkipSectionError] when it receives a interrupt signal. Raises: SkipSectionError: To indicate the current section should be skipped \"\"\" log . debug ( \"Received interrupt raising skip section error\" ) raise SkipSectionError ()","title":"skip_on_interrupt_sig_handler()"},{"location":"reference/util/#cr_kyoushi.simulation.util.sleep","text":"Skipable sleep function This function utilizes the [ skip_on_interrupt ][cr_kyoushi.simulation.util.skip_on_interrupt] context manager to implement a skipable sleep. SIGINT is used used as skip signal. For CLI applications simply press Ctrl + C to skip to interrupt the sleep. Note If you wish to send the SIGINT signal to the main process press Ctrl + C twice. Source code in simulation/util.py def sleep ( sleep_time : Union [ ApproximateFloat , float ]) -> None : \"\"\"Skipable sleep function This function utilizes the [`skip_on_interrupt`][cr_kyoushi.simulation.util.skip_on_interrupt] context manager to implement a skipable sleep. `SIGINT` is used used as skip signal. For CLI applications simply press ++ctrl+c++ to skip to interrupt the sleep. !!! Note If you wish to send the `SIGINT` signal to the main process press ++ctrl+c++ twice. \"\"\" if isinstance ( sleep_time , ApproximateFloat ): sleep_time = sleep_time . value with skip_on_interrupt (): log . debug ( \"Going to sleep for %f \" , sleep_time ) time . sleep ( sleep_time ) log . debug ( \"Resuming execution after sleeping for %f \" , sleep_time )","title":"sleep()"},{"location":"reference/util/#cr_kyoushi.simulation.util.sleep_until","text":"Sleep until specified datetime The default behavior is to basically binary search towards the target datetime. i.e., the sleep duration is always time left/2 until min sleep amount is larger than the division result. Alternatively fixed sleep steps can be configured. Hint You can interupt the current sleep and check if the desired datetime is already reached by pressing Ctrl + C and sending a SIGINT . Parameters: Name Type Description Default end_datetime datetime The datetime to wait until required min_sleep_amount float The minimum amount of time sleep in between checks. 0.1 sleep_amount Optional[Union[float, ApproximateFloat]] Optionally use fixed amount of time sleep steps None Source code in simulation/util.py def sleep_until ( end_datetime : datetime , min_sleep_amount : float = 0.1 , sleep_amount : Optional [ Union [ float , ApproximateFloat ]] = None , ): \"\"\"Sleep until specified datetime The default behavior is to basically binary search towards the target datetime. i.e., the sleep duration is always `time left/2` until min sleep amount is larger than the division result. Alternatively fixed sleep steps can be configured. !!! Hint You can interupt the current sleep and check if the desired datetime is already reached by pressing ++ctrl+c++ and sending a `SIGINT`. Args: end_datetime: The datetime to wait until min_sleep_amount: The minimum amount of time sleep in between checks. sleep_amount: Optionally use fixed amount of time sleep steps \"\"\" while True : diff = ( end_datetime - now ()) . total_seconds () # stop waiting once its the end time or later if diff <= 0 : return # if we do not have a sleep interval sleep relative to # the time between now and the end time if sleep_amount is None : # to avoid many extremely short sleeps # fallback to the minimum sleep sleep ( max ( min_sleep_amount , diff / 2 )) else : sleep ( sleep_amount )","title":"sleep_until()"},{"location":"reference/util/#cr_kyoushi.simulation.util.version_info","text":"Returns formatted version information about the cr_kyoushi.simulation package . Adapted from Pydantic version.py Source code in simulation/util.py def version_info ( cli_info : Info ) -> str : \"\"\"Returns formatted version information about the `cr_kyoushi.simulation package`. Adapted from [Pydantic version.py](https://github.com/samuelcolvin/pydantic/blob/master/pydantic/version.py) \"\"\" import platform import sys from pathlib import Path from . import __version__ info = { \"cr_kyoushi.simulation version\" : __version__ , \"config path\" : cli_info . settings_path . absolute () if cli_info . settings_path is not None else None , \"install path\" : Path ( __file__ ) . resolve () . parent , \"python version\" : sys . version , \"platform\" : platform . platform (), } return \" \\n \" . join ( \" {:>30} {} \" . format ( k + \":\" , str ( v ) . replace ( \" \\n \" , \" \" )) for k , v in info . items () )","title":"version_info()"},{"location":"usage/cli/","text":"CLI Reference \u00b6 This page provides documentation for our command line tools. cr-kyoushi-sim \u00b6 Run Cyber Range Kyoushi Simulation. Usage: cr-kyoushi-sim [OPTIONS] COMMAND [ARGS]... Options: --log-level [CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET] The log level --seed INTEGER Global seeds for PRNGs used during simulation -c, --config FILE The Cyber Range Kyoushi Simulation settings file [default: config.yml] --help Show this message and exit. cr-kyoushi-sim list \u00b6 List available state machine factories. Usage: cr-kyoushi-sim list [OPTIONS] Options: --help Show this message and exit. cr-kyoushi-sim run \u00b6 Execute a state machine. Usage: cr-kyoushi-sim run [OPTIONS] Options: -s, --sm-config FILE The state machine configuration file [default: sm.yml] -f, --factory TEXT The state machine factory to use. This can be either the name of a statemachine factory entrypoint plugin or the path to a python file containing a statemachine factory. [required] --help Show this message and exit. cr-kyoushi-sim version \u00b6 Get the library version. Usage: cr-kyoushi-sim version [OPTIONS] Options: --help Show this message and exit.","title":"CLI Reference"},{"location":"usage/cli/#cli-reference","text":"This page provides documentation for our command line tools.","title":"CLI Reference"},{"location":"usage/cli/#cr-kyoushi-sim","text":"Run Cyber Range Kyoushi Simulation. Usage: cr-kyoushi-sim [OPTIONS] COMMAND [ARGS]... Options: --log-level [CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET] The log level --seed INTEGER Global seeds for PRNGs used during simulation -c, --config FILE The Cyber Range Kyoushi Simulation settings file [default: config.yml] --help Show this message and exit.","title":"cr-kyoushi-sim"},{"location":"usage/cli/#cr-kyoushi-sim-list","text":"List available state machine factories. Usage: cr-kyoushi-sim list [OPTIONS] Options: --help Show this message and exit.","title":"list"},{"location":"usage/cli/#cr-kyoushi-sim-run","text":"Execute a state machine. Usage: cr-kyoushi-sim run [OPTIONS] Options: -s, --sm-config FILE The state machine configuration file [default: sm.yml] -f, --factory TEXT The state machine factory to use. This can be either the name of a statemachine factory entrypoint plugin or the path to a python file containing a statemachine factory. [required] --help Show this message and exit.","title":"run"},{"location":"usage/cli/#cr-kyoushi-sim-version","text":"Get the library version. Usage: cr-kyoushi-sim version [OPTIONS] Options: --help Show this message and exit.","title":"version"},{"location":"usage/configuration/","text":"The Cyber Range Kyoushi Simulation CLI supports two different configuration files. CLI Settings (default path config.yml ) State Machine Config (default path sm.yml ) Supported File Formats \u00b6 YAML loaded with ruamel CLI Settings \u00b6 The CLI settings are used to configure the CLI scripts behavior it self e.g., logging and the plugin system. Pydantic settings management is used for this. As such it is possible to override the default value using environment variables. Note Fields which are nested Pydantic Models must be set using JSON encoded environment variables. Sadly directly setting nested fields is currently not supported. Also some of the configuration settings can also be overridden by CLI options and arguments (see the CLI reference ). See the config module reference for the complete settings model and and its sub models. The following is a complete settings file with all default values: # plugin system configuration plugin : # factory entry point plugins which should or should not be loaded include_names : - .* exclude_names : [] # logging configuration log : # the log level level : WARNING # configuration for the timestamp format timestamp : # string format # (if this is no set a unix epoch timestamp will be used) format : null # use UTC time or the local time utc : True # the log event key to use key : \"timestamp\" # configuration of the console logger console : enabled : yes # output format format : colored # configuration of the file logger file : enabled : no format : json # the path to log to path : sm.log State Machine Configuration \u00b6 State machines that require or optionally provide configuration options can do so via the state machine configuration file (default path sm.yml ). The configuration file can be in any format supported by the CLIs' configuration system (see above). This the configuration file will automatically be loaded and converted to the config class for your state machine factory (see [ StatemachineFactory.config_class ][cr_kyoushi.simulation.sm.StatemachineFactory.config_class]). The system supports both raw configuration in the form of Python dictionaries or as Pydantic Models . It is recommend to use Pydantic for as this allows the CLI system to validate the correctness of the configuration options for you. Hint You can also use a BaseSettings as the base class for your configuration, if you want to enable support environment variables for your state machine configuration. The state machine configuration can be very useful tool for creating more dynamic state machines. For example you could easily create a probabilistic state machine with configurable probabilities for transitions. Using Pydantic you can also ensure that these probabilities are validated on configuration load time.","title":"Configuration"},{"location":"usage/configuration/#supported-file-formats","text":"YAML loaded with ruamel","title":"Supported File Formats"},{"location":"usage/configuration/#cli-settings","text":"The CLI settings are used to configure the CLI scripts behavior it self e.g., logging and the plugin system. Pydantic settings management is used for this. As such it is possible to override the default value using environment variables. Note Fields which are nested Pydantic Models must be set using JSON encoded environment variables. Sadly directly setting nested fields is currently not supported. Also some of the configuration settings can also be overridden by CLI options and arguments (see the CLI reference ). See the config module reference for the complete settings model and and its sub models. The following is a complete settings file with all default values: # plugin system configuration plugin : # factory entry point plugins which should or should not be loaded include_names : - .* exclude_names : [] # logging configuration log : # the log level level : WARNING # configuration for the timestamp format timestamp : # string format # (if this is no set a unix epoch timestamp will be used) format : null # use UTC time or the local time utc : True # the log event key to use key : \"timestamp\" # configuration of the console logger console : enabled : yes # output format format : colored # configuration of the file logger file : enabled : no format : json # the path to log to path : sm.log","title":"CLI Settings"},{"location":"usage/configuration/#state-machine-configuration","text":"State machines that require or optionally provide configuration options can do so via the state machine configuration file (default path sm.yml ). The configuration file can be in any format supported by the CLIs' configuration system (see above). This the configuration file will automatically be loaded and converted to the config class for your state machine factory (see [ StatemachineFactory.config_class ][cr_kyoushi.simulation.sm.StatemachineFactory.config_class]). The system supports both raw configuration in the form of Python dictionaries or as Pydantic Models . It is recommend to use Pydantic for as this allows the CLI system to validate the correctness of the configuration options for you. Hint You can also use a BaseSettings as the base class for your configuration, if you want to enable support environment variables for your state machine configuration. The state machine configuration can be very useful tool for creating more dynamic state machines. For example you could easily create a probabilistic state machine with configurable probabilities for transitions. Using Pydantic you can also ensure that these probabilities are validated on configuration load time.","title":"State Machine Configuration"},{"location":"usage/getting_started/","text":"Cyber Range Kyoushi Simulation provides and API and CLI for developing and running state machines for simulating various actors in cyber ranges. The development API revolves around 6 major components [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] [ Context ][cr_kyoushi.simulation.model.Context] [ State ][cr_kyoushi.simulation.states.State] [ Transition ][cr_kyoushi.simulation.transitions.Transition] [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] [ StatemachineFactory ][cr_kyoushi.simulation.sm.StatemachineFactory] Simulation state machines are defined by combining these 6 components. Statemachine \u00b6 The [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] base class provides the high level state machine execution logic for state machines. In its most basic form it is initialized with a initial state and a list of states . After initialization a state machine can either be executed autonomously via [ Statemachine.run() ][cr_kyoushi.simulation.sm.Statemachine.run] or manually via [ Statemachine.execute_step(...) ][cr_kyoushi.simulation.sm.Statemachine.execute_step]. State machines will execute according to the [ transitions ][cr_kyoushi.simulation.transitions.Transition] defined in its [ states ][cr_kyoushi.simulation.states.State]. When using [ Statemachine.run() ][cr_kyoushi.simulation.sm.Statemachine.run] execution will keep executing state transitions until either an end state is reached (defined as None ) or the current state has no outgoing transitions (i.e., [ State.next(...) ][cr_kyoushi.simulation.states.State.next] returns None ). Other thant the base [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] the API also provides other state machine classes which modify normal state machine behavior. See the sm module code reference for all available state machine types. Hint If you wish to change or extend high basic state machine execution flow you can extend [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] or one of its sub classes. Context \u00b6 The state machine execution context is used to pass information between the various states and transitions. Allowed context types are Dict [ str , Any ] or Pydantic Models . A state machine execution context can be helpful when you complex a state machine for which some of the states or transitions depend on some shared information or objects. For example if you are working with Selenium you might want to store your Selenium driver in the context so that your transitions and states can all access the same Browser instance. The [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] also implements simple context life cycle through the [ Statemachine.setup_context ][cr_kyoushi.simulation.sm.Statemachine.setup_context] and [ Statemachine.destroy_context ][cr_kyoushi.simulation.sm.Statemachine.destroy_context] methods. You can use extend this methods to ensure that your custom context is properly initialized and destroyed in accordance with the state machine execution flow. Warning If you do not use [ Statemachine.run() ][cr_kyoushi.simulation.sm.Statemachine.run] and instead choose to manually execute your state machine you have to call the setup and destroy methods yourself before starting and stopping execution. While you could also achieve something similar to the context by initializing custom State or Transition classes with e.g., a shared driver object it is preferred to use the context for such things as it helps keep your code simple. Also life cycle management for such custom solutions would have to be implemented and integrated with the state machine as well. State \u00b6 A [ State ][cr_kyoushi.simulation.states.State] has zero or more out going transitions and implements the method [ State.next(...) ][cr_kyoushi.simulation.states.State.next]. Each state also must have a unique [ name ][cr_kyoushi.simulation.states.State.name] property so it can be stored in a dictionary ( name -> State ). The next(..) method used in the state machine execution flow to determine the next transition to execute. It is important to select the State type that fits your state machines definition e.g., if you want to implement a probabilistic finite state machine the [ ProbabilisticState ][cr_kyoushi.simulation.states.ProbabilisticState] might be a good fit. See the states module for all the provided state types. Hint You can also always implement a custom State if you need a more specific transition selection e.g., based on some of your context information. Transitions and Transition Functions \u00b6 While states define the flow of the state machine transitions and transition functions define its actions. A [ Transition ][cr_kyoushi.simulation.transitions.Transition] always has a name, target state and transition function. Reminder A target state of None indicates the final state i.e., end of execution. Alternatively you can also use [ FinalState ][cr_kyoushi.simulation.states.FinalState] if you wish to define end states more explicitly. The [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] is what ultimately contains your custom code. What actually is executed depends on your state machine e.g., your transition function could use a Selenium driver to navigate from one page ( current state ) to another page ( target state ). The [ Transition ][cr_kyoushi.simulation.transitions.Transition] object that wraps your transition function determines how your transition function is executed and handles all state machine related actions (e.g., returning the target state). You can extend the base transition class if you whish to change this behavior, for example, the [ DelayedTransition ][cr_kyoushi.simulation.transitions.DelayedTransition] class makes it possible the define a pre or post transition function execution delay. This might be useful when simulating human behavior as humans tend to think before or after they do something. Alternatively you could also implement a custom transition class that executes a different transition function depending on the current state or context . Warning While the API does not enforce it its recommend that a single transition instance only has one target state. This is recommend to keep state machine implementations as understandable as possible. Divergence from normal behavior due to errors are an exception to this and are made possible through [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError]. Stateless vs Stateful Transition Functions \u00b6 Transition functions can be defined as either functions (stateless) or as callable objects (stateful). They only need to implement the [ TransitionFunction protocol ][cr_kyoushi.simulation.transitions.TransitionFunction]. For example the following would be a stateless transition function def goto_city_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"The weather is ok so I am going to { context . chosen_city } now ...\" ) We call this a stateless transition function, because it does not have its own internal state, i.e., variables that persist across multiple executions. Stateless transition functions can only use the context object to store and read information. Sometimes this is not enough as you might have many transition functions that require their own state variables e.g., a transition function that increases a count and prints it out. If you have many such functions your context object might contain many many fields that are only ever used by a single transition function and do not necessarily need to be shared with other states and transitions. In such cases you might prefer to store this information outside the context object to avoid this clutter. Another use case for stateful transition functions would be functions that can be configured to do something a specific way depending on the state machine configuration. As such stateful transition functions can simply be defined as callable objects where the __call__ method implements the [ TransitionFunction protocol ][cr_kyoushi.simulation.transitions.TransitionFunction]. As objects they can then be initialized based on the configuration and they can also store their own state as attributes. class SayHello : \"\"\"Transition function for the initial hello world message\"\"\" def __init__ ( self , traveler_name : StrictStr , desired_weather : Weather ): self . traveler_name = traveler_name self . desired_weather = desired_weather def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"Hi I am { self . traveler_name } . \" f \"I like to travel to cities that have { self . desired_weather } weather.\" ) Creating Transition Instances \u00b6 The API provides to ways to create transition objects either by simply constructing one of the transition types with a transition function as its argument e.g., hello = transitions . Transition ( name = \"hello\" , transition_function = say_hello , target = \"selecting_city\" , ) or in case of stateless transitions you can also use a transition decorator (e.g., [ transition ][cr_kyoushi.simulation.transitions.transition]) that can directly wrap a transition function definition into a transition object. @transitions . transition ( target = \"selecting_city\" ) def hello ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"Hi I am { context . traveler } . \" f \"I like to travel to cities that have { context . desired_weather } weather.\" ) Using transition decorators for stateless transitions can save you some extra code and also makes it very clear which transition executes which transition function. As stateful transition functions are classes and only become actual functions after they have been initialized you cannot use transition decorators with them. Hint The API provides transition decorators for all its transition types. The decorator name is usually just camel case of the transition types class name. Statemachine Factories \u00b6 Cyber Range Kyoushi Simulation also provides a CLI script for executing user defined state machines. For this it provides the concept of [ StatemachineFactories ][cr_kyoushi.simulation.sm.StatemachineFactory] to allow users to make their state machine implementations available to the CLI script. A state machine factory must have a human readable name, a config class and a [build method][cr_kyoushi.simulation.sm.StatemachineFactory.build] that can be called by the CLI to create the state machine instance. The CLI will also load and initialize your config class based on the user supplied state machine configuration file on run time. Note The CLI supports config dict or Pydantic models as config classes. It is recommend to use Pydantic as Pydantic models are automatically validated by the CLI. Hint See the configuration section for more details on CLI and state machine configuration. The build method is the most important part of a state machine factory. The CLI will automatically call this function to initialize the state machine instance as such you have to ensure that all the state, transition setup is done here and the final state machine object is returned. To keep your code a bit more structured you could also want define a few helper methods (e.g., build_transitions(..) ) that handle specific parts of the build process and are called from within the main build method. A simple factory might look like this: ... class StatemachineFactory ( sm . StatemachineFactory ): @property def name ( self ) -> str : return \"GettingStartedStatemachineFactory\" @property def config_class ( self ): return dict def build ( self , config : dict ): # setup the states initial = states . SequentialState ( \"initial\" , init_transition ) example_state = states . SequentialState ( \"example_state\" , example_transition ) end = states . FinalState ( \"end\" ) # Initialize the state machine return GettingStartedStatemachine ( \"initial\" , [ initial , example_state , end ], ) ... See the examples section for complete example state machine implementations. Plugin System \u00b6 There are two ways for a user to make their state machine factory accessible for the CLI system. Either through i n the form of an entry point plugin using the entry point cr_kyoushi.simulation or through a self contained python file that declares a StatemachineFactory class. Both approaches have their advantages and disadvantages. Entry point plugins only work if the state machine code is installed as a proper python package, but by using this approach you can use multiple python files (modules) to define your state machine. This can potential make your code more readable and manageable. Python script plugins have the advantage that they can be used as is not package config etc. required, but you will have to keep all your in a single file or have to ensure that imports for your custom modules are resolvable via the python path (e.g., relative imports will cause exceptions). Also with a pythons script plugin you can only provide a single state machine while you could expose multiple entry point plugins using a single package. Important Regardless which plugin type you use your StatemachineFactory must have a default no arguments __init__ method so the plugin system can create an instance of your factory.","title":"Getting Started"},{"location":"usage/getting_started/#statemachine","text":"The [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] base class provides the high level state machine execution logic for state machines. In its most basic form it is initialized with a initial state and a list of states . After initialization a state machine can either be executed autonomously via [ Statemachine.run() ][cr_kyoushi.simulation.sm.Statemachine.run] or manually via [ Statemachine.execute_step(...) ][cr_kyoushi.simulation.sm.Statemachine.execute_step]. State machines will execute according to the [ transitions ][cr_kyoushi.simulation.transitions.Transition] defined in its [ states ][cr_kyoushi.simulation.states.State]. When using [ Statemachine.run() ][cr_kyoushi.simulation.sm.Statemachine.run] execution will keep executing state transitions until either an end state is reached (defined as None ) or the current state has no outgoing transitions (i.e., [ State.next(...) ][cr_kyoushi.simulation.states.State.next] returns None ). Other thant the base [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] the API also provides other state machine classes which modify normal state machine behavior. See the sm module code reference for all available state machine types. Hint If you wish to change or extend high basic state machine execution flow you can extend [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] or one of its sub classes.","title":"Statemachine"},{"location":"usage/getting_started/#context","text":"The state machine execution context is used to pass information between the various states and transitions. Allowed context types are Dict [ str , Any ] or Pydantic Models . A state machine execution context can be helpful when you complex a state machine for which some of the states or transitions depend on some shared information or objects. For example if you are working with Selenium you might want to store your Selenium driver in the context so that your transitions and states can all access the same Browser instance. The [ Statemachine ][cr_kyoushi.simulation.sm.Statemachine] also implements simple context life cycle through the [ Statemachine.setup_context ][cr_kyoushi.simulation.sm.Statemachine.setup_context] and [ Statemachine.destroy_context ][cr_kyoushi.simulation.sm.Statemachine.destroy_context] methods. You can use extend this methods to ensure that your custom context is properly initialized and destroyed in accordance with the state machine execution flow. Warning If you do not use [ Statemachine.run() ][cr_kyoushi.simulation.sm.Statemachine.run] and instead choose to manually execute your state machine you have to call the setup and destroy methods yourself before starting and stopping execution. While you could also achieve something similar to the context by initializing custom State or Transition classes with e.g., a shared driver object it is preferred to use the context for such things as it helps keep your code simple. Also life cycle management for such custom solutions would have to be implemented and integrated with the state machine as well.","title":"Context"},{"location":"usage/getting_started/#state","text":"A [ State ][cr_kyoushi.simulation.states.State] has zero or more out going transitions and implements the method [ State.next(...) ][cr_kyoushi.simulation.states.State.next]. Each state also must have a unique [ name ][cr_kyoushi.simulation.states.State.name] property so it can be stored in a dictionary ( name -> State ). The next(..) method used in the state machine execution flow to determine the next transition to execute. It is important to select the State type that fits your state machines definition e.g., if you want to implement a probabilistic finite state machine the [ ProbabilisticState ][cr_kyoushi.simulation.states.ProbabilisticState] might be a good fit. See the states module for all the provided state types. Hint You can also always implement a custom State if you need a more specific transition selection e.g., based on some of your context information.","title":"State"},{"location":"usage/getting_started/#transitions-and-transition-functions","text":"While states define the flow of the state machine transitions and transition functions define its actions. A [ Transition ][cr_kyoushi.simulation.transitions.Transition] always has a name, target state and transition function. Reminder A target state of None indicates the final state i.e., end of execution. Alternatively you can also use [ FinalState ][cr_kyoushi.simulation.states.FinalState] if you wish to define end states more explicitly. The [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] is what ultimately contains your custom code. What actually is executed depends on your state machine e.g., your transition function could use a Selenium driver to navigate from one page ( current state ) to another page ( target state ). The [ Transition ][cr_kyoushi.simulation.transitions.Transition] object that wraps your transition function determines how your transition function is executed and handles all state machine related actions (e.g., returning the target state). You can extend the base transition class if you whish to change this behavior, for example, the [ DelayedTransition ][cr_kyoushi.simulation.transitions.DelayedTransition] class makes it possible the define a pre or post transition function execution delay. This might be useful when simulating human behavior as humans tend to think before or after they do something. Alternatively you could also implement a custom transition class that executes a different transition function depending on the current state or context . Warning While the API does not enforce it its recommend that a single transition instance only has one target state. This is recommend to keep state machine implementations as understandable as possible. Divergence from normal behavior due to errors are an exception to this and are made possible through [ TransitionExecutionErrors ][cr_kyoushi.simulation.errors.TransitionExecutionError].","title":"Transitions and Transition Functions"},{"location":"usage/getting_started/#stateless-vs-stateful-transition-functions","text":"Transition functions can be defined as either functions (stateless) or as callable objects (stateful). They only need to implement the [ TransitionFunction protocol ][cr_kyoushi.simulation.transitions.TransitionFunction]. For example the following would be a stateless transition function def goto_city_transition ( log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"The weather is ok so I am going to { context . chosen_city } now ...\" ) We call this a stateless transition function, because it does not have its own internal state, i.e., variables that persist across multiple executions. Stateless transition functions can only use the context object to store and read information. Sometimes this is not enough as you might have many transition functions that require their own state variables e.g., a transition function that increases a count and prints it out. If you have many such functions your context object might contain many many fields that are only ever used by a single transition function and do not necessarily need to be shared with other states and transitions. In such cases you might prefer to store this information outside the context object to avoid this clutter. Another use case for stateful transition functions would be functions that can be configured to do something a specific way depending on the state machine configuration. As such stateful transition functions can simply be defined as callable objects where the __call__ method implements the [ TransitionFunction protocol ][cr_kyoushi.simulation.transitions.TransitionFunction]. As objects they can then be initialized based on the configuration and they can also store their own state as attributes. class SayHello : \"\"\"Transition function for the initial hello world message\"\"\" def __init__ ( self , traveler_name : StrictStr , desired_weather : Weather ): self . traveler_name = traveler_name self . desired_weather = desired_weather def __call__ ( self , log : BoundLogger , current_state : str , context : TravelerContext , target : Optional [ str ], ): print ( f \"Hi I am { self . traveler_name } . \" f \"I like to travel to cities that have { self . desired_weather } weather.\" )","title":"Stateless vs Stateful Transition Functions"},{"location":"usage/getting_started/#creating-transition-instances","text":"The API provides to ways to create transition objects either by simply constructing one of the transition types with a transition function as its argument e.g., hello = transitions . Transition ( name = \"hello\" , transition_function = say_hello , target = \"selecting_city\" , ) or in case of stateless transitions you can also use a transition decorator (e.g., [ transition ][cr_kyoushi.simulation.transitions.transition]) that can directly wrap a transition function definition into a transition object. @transitions . transition ( target = \"selecting_city\" ) def hello ( log , current_state : str , context : TravelerContext , target : Optional [ str ]): print ( f \"Hi I am { context . traveler } . \" f \"I like to travel to cities that have { context . desired_weather } weather.\" ) Using transition decorators for stateless transitions can save you some extra code and also makes it very clear which transition executes which transition function. As stateful transition functions are classes and only become actual functions after they have been initialized you cannot use transition decorators with them. Hint The API provides transition decorators for all its transition types. The decorator name is usually just camel case of the transition types class name.","title":"Creating Transition Instances"},{"location":"usage/getting_started/#statemachine-factories","text":"Cyber Range Kyoushi Simulation also provides a CLI script for executing user defined state machines. For this it provides the concept of [ StatemachineFactories ][cr_kyoushi.simulation.sm.StatemachineFactory] to allow users to make their state machine implementations available to the CLI script. A state machine factory must have a human readable name, a config class and a [build method][cr_kyoushi.simulation.sm.StatemachineFactory.build] that can be called by the CLI to create the state machine instance. The CLI will also load and initialize your config class based on the user supplied state machine configuration file on run time. Note The CLI supports config dict or Pydantic models as config classes. It is recommend to use Pydantic as Pydantic models are automatically validated by the CLI. Hint See the configuration section for more details on CLI and state machine configuration. The build method is the most important part of a state machine factory. The CLI will automatically call this function to initialize the state machine instance as such you have to ensure that all the state, transition setup is done here and the final state machine object is returned. To keep your code a bit more structured you could also want define a few helper methods (e.g., build_transitions(..) ) that handle specific parts of the build process and are called from within the main build method. A simple factory might look like this: ... class StatemachineFactory ( sm . StatemachineFactory ): @property def name ( self ) -> str : return \"GettingStartedStatemachineFactory\" @property def config_class ( self ): return dict def build ( self , config : dict ): # setup the states initial = states . SequentialState ( \"initial\" , init_transition ) example_state = states . SequentialState ( \"example_state\" , example_transition ) end = states . FinalState ( \"end\" ) # Initialize the state machine return GettingStartedStatemachine ( \"initial\" , [ initial , example_state , end ], ) ... See the examples section for complete example state machine implementations.","title":"Statemachine Factories"},{"location":"usage/getting_started/#plugin-system","text":"There are two ways for a user to make their state machine factory accessible for the CLI system. Either through i n the form of an entry point plugin using the entry point cr_kyoushi.simulation or through a self contained python file that declares a StatemachineFactory class. Both approaches have their advantages and disadvantages. Entry point plugins only work if the state machine code is installed as a proper python package, but by using this approach you can use multiple python files (modules) to define your state machine. This can potential make your code more readable and manageable. Python script plugins have the advantage that they can be used as is not package config etc. required, but you will have to keep all your in a single file or have to ensure that imports for your custom modules are resolvable via the python path (e.g., relative imports will cause exceptions). Also with a pythons script plugin you can only provide a single state machine while you could expose multiple entry point plugins using a single package. Important Regardless which plugin type you use your StatemachineFactory must have a default no arguments __init__ method so the plugin system can create an instance of your factory.","title":"Plugin System"},{"location":"usage/logging/","text":"The Cyber Range Kyoushi CLI uses structlog as its logging framework. Structlog makes it possible to add additional keys to log messages allowing us to create more structured and annotated log messages. This also enables us to easily provide both human and computer readable log formats (e.g., JSON) which can then later be parsed by other Cyber Range Kyoushi framework tools. Usage \u00b6 The 3 main execution flow method calls [ State.next ][cr_kyoushi.simulation.states.State.next], [ Transition.execute ][cr_kyoushi.simulation.transitions.Transition.execute] and [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] are passed a log object. This log object is already pre initialized with some information about the state machine execution as extra log record keys: run : A UUID uniquely identifying the state machine run transition_id : A UUID uniquely identifying the current transition execution state : The current states name transition : The current transitions name target : The transitions target states name \u00b6 As such it is highly recommended to use this log object when logging state machine execution related log messages. For logging other things such as initialization in your state machine factory use the logger provided by the [ get_logger ][cr_kyoushi.simulation.logging.get_logger] function from the logging module. Important You can use any object that is JSON serializable by Pydantics' custom JSON encoder. Note that for Pydantic Models custom encoders are currently not supported. All non serializable objects must be converted to a serializable format before logging them. Key Binding \u00b6 You can log normal messages as you would with the Python native logging module log . info ( \"This is the %d message\" , count ) or you can also include extra keys log . info ( \"This is the %d message\" , count , message_id = uuid4 ()) Structlog also allows you to bind keys to a log instance so it will be included in all future log messages. # bind adds keys to the current bindings log = log . bind ( message_id = uuid4 ()) log . info ( \"This is the %d message\" , count ) log . info ( \"It is sunny outside\" ) count ++ # new will clear out the current bindings log = log . new ( foo = \"bar\" ) log . info ( \"This is the %d message\" , count ) log . info ( \"It is sunny outside\" ) This is the 1 message message_id = UUID ( '012a36e9-c5b0-4b98-a804-ae9b0cd1b870' ) It is sunny outside message_id = UUID ( '012a36e9-c5b0-4b98-a804-ae9b0cd1b870' ) This is the 2 message foo = bar It is sunny outside foo = bar See the structlog documentation for more details.","title":"Logging"},{"location":"usage/logging/#usage","text":"The 3 main execution flow method calls [ State.next ][cr_kyoushi.simulation.states.State.next], [ Transition.execute ][cr_kyoushi.simulation.transitions.Transition.execute] and [ TransitionFunction ][cr_kyoushi.simulation.transitions.TransitionFunction] are passed a log object. This log object is already pre initialized with some information about the state machine execution as extra log record keys: run : A UUID uniquely identifying the state machine run transition_id : A UUID uniquely identifying the current transition execution state : The current states name transition : The current transitions name","title":"Usage"},{"location":"usage/logging/#target-the-transitions-target-states-name","text":"As such it is highly recommended to use this log object when logging state machine execution related log messages. For logging other things such as initialization in your state machine factory use the logger provided by the [ get_logger ][cr_kyoushi.simulation.logging.get_logger] function from the logging module. Important You can use any object that is JSON serializable by Pydantics' custom JSON encoder. Note that for Pydantic Models custom encoders are currently not supported. All non serializable objects must be converted to a serializable format before logging them.","title":"target: The transitions target states name"},{"location":"usage/logging/#key-binding","text":"You can log normal messages as you would with the Python native logging module log . info ( \"This is the %d message\" , count ) or you can also include extra keys log . info ( \"This is the %d message\" , count , message_id = uuid4 ()) Structlog also allows you to bind keys to a log instance so it will be included in all future log messages. # bind adds keys to the current bindings log = log . bind ( message_id = uuid4 ()) log . info ( \"This is the %d message\" , count ) log . info ( \"It is sunny outside\" ) count ++ # new will clear out the current bindings log = log . new ( foo = \"bar\" ) log . info ( \"This is the %d message\" , count ) log . info ( \"It is sunny outside\" ) This is the 1 message message_id = UUID ( '012a36e9-c5b0-4b98-a804-ae9b0cd1b870' ) It is sunny outside message_id = UUID ( '012a36e9-c5b0-4b98-a804-ae9b0cd1b870' ) This is the 2 message foo = bar It is sunny outside foo = bar See the structlog documentation for more details.","title":"Key Binding"}]}